<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[spring]]></title>
    <url>%2F2016%2F05%2F07%2Fspring%2Bspringmvc%2Bshiro%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[面试题 这些Spring面试题是从尚硅谷http://www.atguigu.com的JavaEE面试题整理出来的，希望对你有帮助！ 开发中主要使用 Spring 的什么技术 ?①. IOC 容器管理各层的组件②. 使用 AOP 配置声明式事务③. 整合其他框架. 简述 AOP 和 IOC 概念AOP: Aspect Oriented Program, 面向(方面)切面的编程;Filter(过滤器)也是一种 AOP. AOP 是一种新的方法论 , 是对传统 OOP(Object-Oriented Programming, 面向对象编程) 的补充. AOP 的主要编程对像是切面(aspect), 而切面模块化横切关注点.可以举例通过事务说明.IOC: Invert Of Control, 控制反转. 也成为 DI(依赖注入)其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源.作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件,组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式. 在 Spring 中如何配置 Bean ?Bean 的配置方式: 通过全类名 （反射）、 通过工厂方法 （静态工厂方法 &amp; 实例工厂方法）、FactoryBean IOC 容器对 Bean 的生命周期:①. 通过构造器或工厂方法创建 Bean 实例②. 为 Bean 的属性设置值和对其他 Bean 的引用③. 将Bean实例传递给Bean后置处理器的postProcessBeforeInitialization 方法④. 调用 Bean 的初始化方法(init-method)⑤. 将Bean实例传递给Bean后置处理器的postProcessAfterInitialization 方法⑦. Bean 可以使用了⑧. 当容器关闭时, 调用 Bean 的销毁方法(destroy-method) 说一下struts2-hibernate-Spring 的工作流程？ 1). Struts2 负责显示页面和接受请求2). Spring 的 IOC 容器管理各个组件: 整合 Struts2，Hibernate 和 其他组件，AOP 完成声明式事务3). Hibernate 提供 DAO 操作. Spring 如何整合 Struts2 ? 整合 Struts2, 即由 IOC 容器管理 Struts2 的 Action: 安装 Spring 插件: 把 struts2-spring-plugin-2.2.1.jar 复制到当前 WEB 应用的 WEB-INF/lib 目录下在 Spring 的配置文件中配置 Struts2 的 Action 实例在 Struts 配置文件中配置 action, 但其 class 属性不再指向该Action 的实现类, 而是指向 Spring 容器中 Action 实例的 ID Spring 如何整合 Hibernate整合 Hibernate, 即由 IOC 容器生成 SessionFactory 对象, 并使用Spring 的声明式事务 利用 LocalSessionFactoryBean 工厂 Bean, 声明一个使用 XML 映射文件的 SessionFactory 实例.利用 HibernateTransactionManager 配置 Hibernate 的事务管理器 Spring MVC 比较 Struts2①. Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter②. Spring MVC 会稍微比 Struts2 快些. Spring MVC 是基于方法设计, 而 Sturts2 是基于类, 每次发一次请求都会实例一个 Action.③. Spring MVC 使用更加简洁, 开发效率 Spring MVC 确实比 struts2 高: 支持 JSR303, 处理 ajax 的请求更方便④. Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些. Spring MVC 的运行流程①. 在整个 Spring MVC 框架中， DispatcherServlet 处于核心位置，负责协调和组织不同组件以完成请求处理并返回响应的工作②. SpringMVC 处理请求过程： 若一个请求匹配 DispatcherServlet 的请求映射路径(在 web.xml 中指定), WEB 容器将该请求转交给 DispatcherServlet 处理DispatcherServlet 接收到请求后, 将根据请求信息(包括 URL、 HTTP 方法、 请求头、 请求参数、 Cookie 等)及 HandlerMapping 的配置找到处理请求的处理器(Handler). 可将 HandlerMapping 看成路由控制器， 将 Handler 看成目标主机。当 DispatcherServlet 根据 HandlerMapping 得到对应当前请求的Handler 后，通过 HandlerAdapter 对 Handler 进行封装，再以统一的适配器接口调用 Handler。 处 理 器 完 成 业 务 逻 辑 的 处 理 后 将 返 回 一 个 ModelAndView 给DispatcherServlet, ModelAndView 包含了视图逻辑名和模型数据信息DispatcherServlet 借助 ViewResoler 完成逻辑视图名到真实视图对象的解析得到真实视图对象 View 后, DispatcherServlet 使用这个 View 对ModelAndView 中的模型数据进行视图渲染https://blog.verysu.com/resources/upload/image/20141129/20141129145306_762.png 说出 Spring MVC 常用的 5 个注解:@RequestMapping 、 @PathVariable 、 @RequestParam 、 @RequestBoy 、@ResponseBody 如何使用 SpringMVC 完成 JSON 操作：①. 配置 MappingJacksonHttpMessageConverter②. 使用 @RequestBody 注解或 ResponseEntity 作为返回值 比较 SpringSecurity 和 Shiro 相比 Spring Security, Shiro 在保持强大功能的同时, 使用简单性和灵活性 SpringSecurity: 即使是一个一个简单的请求，最少得经过它的 8 个FilterSpringSecurity 必须在 Spring 的环境下使用初学 Spring Security, 曲线还是较大, 需要深入学习其源码和框架, 配置起来也较费力. Shiro 的优点 简单的身份认证, 支持多种数据源对角色的简单的授权, 支持细粒度的授权(方法级)支持一级缓存，以提升应用程序的性能；内置的基于 POJO 企业会话管理, 适用于 Web 以及非 Web 的环境非常简单的加密 API不跟任何的框架或者容器捆绑, 可以独立运行 简述 Shiro 的核心组件 Shiro 架构 3 个核心组件: Subject: 正与系统进行交互的人, 或某一个第三方服务.所有 Subject 实例都被绑定到（且这是必须的）一个SecurityManager 上。SecurityManager: Shiro 架构的心脏, 用来协调内部各安全组件, 管理内部组件实例, 并通过它来提供安全管理的各种服务.当 Shiro 与一个 Subject 进行交互时, 实质上是幕后的 SecurityManager 处理所有繁重的 Subject 安全操作。Realms: 本质上是一个特定安全的 DAO. 当配置 Shiro 时, 必须指定至少一个 Realm 用来进行身份验证和/或授权.Shiro 提供了多种可用的 Realms 来获取安全相关的数据. 如关系数据库(JDBC), INI 及属性文件等.可以定义自己 Realm 实现来代表自定义的数据源。 Shiro认证过程 ①. 应用程序代码调用 Subject.login 方法，传递创建好的包含终端用户的 Principals(身份)和 Credentials(凭证)的 AuthenticationToken 实例②. Subject 实例: 通常为 DelegatingSubject(或子类)委托应用程序的 SecurityManager 通过调用securityManager.login(token) 开始真正的验证。③. SubjectManager 接收 token，调用内部的 Authenticator 实例调用 authenticator.authenticate(token).Authenticator 通常是一个 ModularRealmAuthenticator 实例, 支持在身份验证中协调一个或多个Realm 实例④. 如果应用程序中配置了一个以上的 Realm, ModularRealmAuthenticator 实例将利用配置好的AuthenticationStrategy 来启动 Multi-Realm 认证尝试. 在Realms 被身份验证调用之前, 期间和以后,AuthenticationStrategy 被调用使其能够对每个Realm 的结果作出反应.⑤. 每个配置的 Realm 用来帮助看它是否支持提交的 AuthenticationToken. 如果支持, 那么支持 Realm 的 getAuthenticationInfo 方法将会伴随着提交的 token 被调用. getAuthenticationInfo 方法有效地代表一个特定 Realm 的单一的身份验证尝试。 https://blog.verysu.com/resources/upload/image/20141129/20141129150045_776.png Shiro授权过程 ①. 应用程序或框架代码调用任何 Subject 的hasRole, checkRole, isPermitted,或者checkPermission方法的变体, 传递任何所需的权限②. Subject 的实例—通常是 DelegatingSubject(或子类), 调用securityManager 的对应的方法.③. SecurityManager 调用 org.apache.shiro.authz.Authorizer 接口的对应方法.默认情况下，authorizer 实例是一个 ModularRealmAuthorizer 实例, 它支持协调任何授权操作过程中的一个或多个Realm 实例④. 每个配置好的 Realm 被检查是否实现了相同的 Authorizer 接口. 如果是, Realm 各自的 hasRole, checkRole,isPermitted，或 checkPermission 方法将被调用。 https://blog.verysu.com/resources/upload/image/20141129/20141129145938_946.png Shiro 如何自实现认证 Shiro 的认证过程由 Realm 执行, SecurityManager 会调用 org.apache.shiro.realm.Realm 的 getAuthenticationInfo(AuthenticationToken token) 方法. 实际开发中, 通常提供 org.apache.shiro.realm.AuthenticatingRealm 的实现类, 并在该实现类中提供 doGetAuthenticationInfo(AuthenticationToken token)方法的具体实现 如何实现自实现授权 实际开发中, 通常提供 org.apache.shiro.realm.AuthorizingRealm 的实现类,并提供 doGetAuthorizationInfo(PrincipalCollection principals) 方法的具体实现 如何配置在 Spring 中配置使用 Shiro ①. 在 web.xml 中配置 Shiro 的 Filter②. 在 Spring 的配置文件中配置 Shiro: 配置自定义 Realm：实现自定义认证和授权配置 Shiro 实体类使用的缓存策略配置 SecurityManager配置保证 Shiro 内部 Bean 声明周期都得到执行的 Lifecycle Bean 后置处理器配置AOP 式方法级权限检查配置 Shiro Filter]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集群间实现session共享]]></title>
    <url>%2F2016%2F04%2F17%2F%E9%9B%86%E7%BE%A4%E9%97%B4%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[一、引言 针对企业，为了应对庞大的用户访问压力，目前大多数大型网站服务器都采用集群部署的方式；针对个人，仅一台服务器而言，也会安装多个tomcat进行错时更新，保证更新后台业务时服务不断开，即模拟了集群的运行方式。在此集群中，我们就不得不考虑一个用户鉴权的问题，即在不同服务上如何保证用户均已登录，并能获取相同的用户登录信息。 二、Java Web推荐的（公认的）用户鉴权机制 说此部分之前先了解几个概念： 1.请求，即Request，指客户端向服务器发送的信息，通常是通信的发起方； 2.响应，即Response，指服务器对请求的应答，通常是通信的回复方； 3.会话，即Session，服务器可将请求&lt;-&gt;响应这一个完整的过程称为一次会话，并为这次会话生成一个唯一的标识符，即sessionId，用来表示这次会话，Session储存在服务器端； 4.Cookie，客户端保存在本地终端的数据，即Cookie储存在客户端。 Java Web的共用的用户鉴权机制是采用Session-Cookie技术，实现原理是：用户登录时，请求到达服务器，服务器调用通过getSession()方法判断session是否存在，如果不存在，则新建session，并通过其算法为session生成一个随机数作为sessionId，开发者可在session中储存一些用户信息；第二次请求时，如获取用户信息，getSession()方法判断session存在，则取出session，而不是新建，从而从session中获取到用户的相关信息。 客户端请求时，可以将cookie信息储存于request的head中发送给服务器； 服务器响应时，可以将cookie信息置于response中回传给客户端。 如下图代表，名称为test的cookie其值为aaa: 那么getSession()里究竟做了什么？ 1.第一次用户请求，客户端本地没有任何数据，即其cookie为空，朝服务器发送request，getSession()中会解析request,发现其约定的cookie为null，则认为没有session，所以会重新创建一个session对象； 2.创建session后会将此session的id放入response中，回传给客户端，客户端则保存response中的cookie； 3.再次请求，服务器getSession()又会重新解析request获取cookie，发现了其中的sessionId，那么根据此sessionId去服务器的中去找，则得到了上次创建的session对象，那么则认为鉴权成功。 如此，便完成了鉴权的整个流程，Java逻辑代码(伪代码)如下： public HttpSession getSession() { //从request中解析cookie HttpSession session = null; Cookie[] cookies = getRequest().getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { if (cookie.getName().equals("JSESSIONID")) { String sessionId = cookie.getValue(); session = //根据sessionId获取内存中的session对象 } } } if (session == null) { session = //创建一个新的session对象 } //通过response将cookie返回 Cookie cookie = new Cookie("JSESSIONID", session.getId()); getResponse().addCookie(cookie); return session; }12345678910111213141516171819202122 如上，java中将sessionId在cookie中保存的名称叫做“JSESSIONID”，即“Java Session Id”之意，打开浏览器可以看到类型的信息，如图： 三、集群间如何实现session共享 按照前文所说的session-cookie机制，session是保存在每台服务器的，但在集群中，拥有多台服务器，每台各自为政，势必会造成在这台服务器中登录，获取session成功，但是到另一台服务器上，又会获取不到session，造成鉴权失败，这样对用户来说是极不友好的，那么怎么解决这个问题呢？ 通过我们以上的分析，即可得出几种处理方式: A.找一块公共的空间用来储存session，而不是将session储存在集群节点的某台服务器上，此时，每一台服务器都能访问这块空间，从而实现session共享； B.仍在每台服务器上保存session信息，不作修改，但采用另一种同步机制，实时同步没一台服务器的session信息； C.构建一种全新的鉴权机制，不采用session-cookie机制，但要去除此鉴权机制对单个服务器的依赖。 综上所述，列举几种的具体实现方案： 1.持久化session到数据库，即使用数据库来储存session。数据库正好是我们普遍使用的公共储存空间，一举两得，推荐使用mysql数据库，轻量并且性能良好。 优点：就地取材，符合大多数人的思维，使用简单，不需要太多额外编码工作 缺点：对mysql性能要求较高，访问mysql需要从连接池中获取连接，又因为大部分请求均需要进行登录鉴权，所以操作数据库非常频繁，当用户量达到一定程度之后，极易造成数据库瓶颈，不适用于处理高并发的情况。 2.使用redis共享session。redis是一个key-value的储存系统。可以简单的将其理解为一个数据库，与传统数据库的区别是，它将数据储存于内存中，并自带有内存到硬盘的序列化策略，即按策略将内存中的数据同步到磁盘，避免数据丢失，是目前比较流行的解决方案。 优点：无需增加数据库的压力，因为数据存储于内存中，所以读取非常快，高性能，并能处理多种类型的数据。 缺点：额外增加一些编码，以便操作redis。 3.使用memcache同步session，memcache可以实现分布式，可将服务器中的内存组合起来，形成一个“内存池”，以此充当公共空间，保存session信息。 优点：数据储存在内存中，读取非常快，性能好； 缺点：memcache把内存分成很多种规格的存储块，有大有小，不能完全利用内存，会产生内存碎片，浪费资源，如果储存块不足，还会产生内存溢出。 4.通过脚本或守护进程在多台服务器之间同步session。 优点：实现了session共享； 缺点：对个人来说实现较为复杂，速度不稳定，有延时性，取决于现实中服务运行状态，偶然性较大，如果用于访问过快，可能出现session还没同步成功的情况。 5.使用NFS共享session。NFS是Network File Server共享服务器的简称，最早由Sun公司为解决Unix网络主机间的目录共享而研发。选择一台公共的NFS做共享服务器，储存所有session数据，每台服务器所需的session均从此处获取。 优点：较好的实现了session共享； 缺点：成本较高，对于个人来说难以实现。NFS依托于复杂的安全机制和文件系统，因此并发效率不高。 6.使用Cookie共享session。此方案可以说是独辟蹊径了，将分布式思想用到了极致。如上文分析所说，session-cookie机制中，session与cookie相互关联，以cookie做中转站，用来找到对应的session，其中session存放在服务器。那么如果将session中的内容存放在cookie中呢，那么则省略了服务器保存session的过程，后台只需要根据cookie中约定的标识进行鉴权校验即可。 优点：完美的贯彻分布式的理念，将每个用户都利用起来，无需耗费额外的服务器资源； 缺点：受http协议头长度限制，cookie中存储的信息不宜过多；为了保持cookie全局有效，所以其一般依赖在根域名下，所以基本上所有的http请求都需要传递cookie中的这些标记信息，所以会占用一些服务器的带宽；鉴权信息全存储于cookie中，cookie存在于客户端，服务器并没有储存相关信息，cookie存在着泄露的可能，或则其他人揣摩出规则后可以进行伪装，其安全性比其他方案差，故需要对cookie中信息进行加密解密，来增强其安全性。 在此，我们将选择方案2使用redis来具体实现集群下的session共享。 四、搭建测试环境 1.为模拟集群环境，需要两台服务器或在一台服务器上安装两个tomcat； 2.使用nginx做集群纷发； 3.安装redis充当公共的空间存储session; 4.框架中编写session储存业务，因为需要使用java操作redis，redis提供了驱动包jedis，故需要掌握jedis进行操作。 五、详细部署 5.1 安装多个tomcat 怎么安装tomcat此处不作说明，只说明安装额外的tomcat，本人原安装的tomcat目录为apache-tomcat-7.0.77 1.拷贝apache-tomcat-7.0.77为apache-tomcat-7.0.77_2 2.修改apache-tomcat-7.0.77_2下conf中server.xml文件端口号 ，共三处，将每处在原端口号port之上加1，确保两个tomcat不会共用端口，如下： &lt;Server port="8006" shutdown="SHUTDOWN"&gt; &lt;Connector port="8081" protocol="HTTP/1.1" connectionTimeout="20000" redirectPort="8443" /&gt; &lt;Connector port="8010" protocol="AJP/1.3" redirectPort="8443" /&gt;1234567 5.2 更改nginx配置，模拟集群 修改nginx配置文件nginx.conf文件，在server闭包外添加upstream，由上可知两个tomcat端口号分别为8080，8081 #建立集群 upstream not_alone { server localhost:8080; server localhost:8081; } # 转发请求到tomcat下mate项目 location / { proxy_pass http://not_alone/mate/; }12345678910 5.2 redis安装与配置 1.下载，官网：https://redis.io/download 2.安装，以4.0.1版本为例 $ wget http://download.redis.io/releases/redis-4.0.1.tar.gz $ tar xzf redis-4.0.1.tar.gz $ cd redis-4.0.1 $ make1234 3.启动 $ src/redis-server1 4.关闭 ctrl + c1 5.配置后台启动（redis默认是前台启动，启动成功后界面就持续停止在那个界面上，这对服务器操作很不方便） #修改其配置文件 vim redis.conf 将daemonize no改为daemonize yes #保存退出 :wq!1234567 如下图： 6.后台启动 src/redis-server redis.conf1 如图： 7.关闭 杀掉redis进程,如图： 8.为redis配置系统服务，本人使用的系统是CentOS 7，需要配置使用systemctl进行管理。 /lib/systemd/system目录下创建文件redis.service，并编辑： #表示服务信息 [Service] Type=forking #注意：需要和redis.conf配置文件中的信息一致 PIDFile=/var/run/redis_6379.pid #启动服务的命令 #redis-server安装的路径 和 redis.conf配置文件的路径 ExecStart=/server/soft/redis-4.0.1/src/redis-server /server/soft/redis-4.0.1/redis.conf #重新加载命令 ExecReload=/bin/kill -s HUP $MAINPID #停止服务的命令 ExecStop=/bin/kill -s QUIT $MAINPID PrivateTmp=true #安装相关信息 [Install] #以哪种方式启动 WantedBy=multi-user.target #multi-user.target表明当系统以多用户方式（默认的运行级别）启动时，这个服务需要被自动运行。12345678910111213141516171819 更多redis systemctl详细配置，请看：http://blog.csdn.net/u011389474/article/details/72303156 配置成功，启动完成后，通过服务可知其运行状态，如图： 至此，redis已全部安装部署完成。 六、编写代码实现功能 为了测试简便，后台web框架我选择的是JFinal，JFinal是中国开源社区中广受好评的后台轻量级极速web框架，因其操作简单，设计灵活而被大多数开发者所喜爱，有兴趣的朋友可以试试，用一次之后你就会喜欢它的，JFinal社区:http://www.jfinal.com/ 这里用JFianl的另一个好处就是JFinal核心库中自带Redis插件，集成了jedis的各种使用方法，这样就不用自己去编写了，省了很大的代码量。Jedis基本操作：http://www.cnblogs.com/edisonfeng/p/3571870.html 为帮助理解代码，Jfinal中连接redis，只需要在主配置文件中编写： /** * 插件配置 */ @Override public void configPlugin(Plugins me) { /* * Redis配置：连接本地的mate redis库，端口号默认 */ RedisPlugin rp = new RedisPlugin("mate", "localhost"); me.add(rp); }1234567891011 redis存取数据： Cache cache = Redis.use(); //存 cache.set(key, value); //取 Object value = cache.get(key); //设置redis过期时间 cache.pexpire(key, time);12345678910 正式代码如下，我们将会自定义session，每个sesison对象都是唯一的，需要给每个session分配一个唯一id，id生成算法，则可以借用UUID实现，UUID相关介绍：https://baike.baidu.com/item/UUID/5921266?fr=aladdin 自定义随机数工具类： /** * 随机数工具类 * @author alone */ public class RandomUtils { /** * 获取唯一的可辨识资讯UUID * UUID为128位二进制，每4位二进制=16进制，其添加了四个'-'，故总长为36位 * @param 是否删除标记 * @return UUID */ public static String getUUID(boolean rmtag) { String uuid = UUID.randomUUID().toString(); if (rmtag) { uuid = uuid.replace("-", ""); } return uuid; } }12345678910111213141516171819 自定义RedisSession类，将替代原来的HttpSession： package com.alone.mate.common; import java.io.Serializable; import java.util.HashMap; import java.util.Map; import com.alone.mate.utils.RandomUtils; import com.jfinal.plugin.redis.Cache; import com.jfinal.plugin.redis.Redis; /** * 自定义ResidSession解决集群会话共享 * @author alone */ @SuppressWarnings("serial") public class RedisSession implements Serializable { private String id; private SessionType type; private long createTime; private long destroyTime; private Map&lt;String, Object&gt; attrs; /** * 会话类型，不同类型的会话其有效期不同 * @author alone */ public enum SessionType { /** * 移动端，类型为1，会话有效期为一周 */ MOBILE(1, 1000 * 60 * 60 * 24 * 7), /** * 网页端，类型为2，会话有效期为半小时 */ BROWSER(2, 1000 * 60 * 30); private int type; private int value; private SessionType(int type, int value) { this.type = type; this.value = value; } public int getType() { return type; } public int getValue() { return value; } public static SessionType getSessionType(int type) { for (SessionType st : SessionType.values()) { if (st.type == type) { return st; } } return null; } } public RedisSession(int sessionType) { this.id = RandomUtils.getUUID(true); this.type = SessionType.getSessionType(sessionType); this.createTime = System.currentTimeMillis(); this.destroyTime = this.createTime + this.type.value; this.attrs = new HashMap&lt;&gt;(); } public Object getAttribute(String key) { return attrs.get(key); } public void setAttribute(String key, Object value) { attrs.put(key, value); Cache cache = Redis.use(); cache.set(this.getId(), this); cache.pexpire(this.getId(), this.getDestroyTime() - System.currentTimeMillis());//set后会将生存时间清零，需要重新设置有效期 } public void removeAttribute(String key) { attrs.remove(key); Cache cache = Redis.use(); cache.set(this.getId(), this); } public String getId() { return id; } public SessionType getType() { return type; } public long getCreateTime() { return createTime; } public long getDestroyTime() { return destroyTime; } public void setDestroyTime(long destroyTime) { this.destroyTime = destroyTime; } } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110 仿造getSession()实现逻辑在控制器基类BaseController中自定义getSession()方法，获取RedisSession： public class BaseController extends Controller { private static final Logger logger = Logger.getLogger(BaseController.class); private String sessionId; /** * 获取RedisSession * @param sessionType 会话类型 * @return */ @SuppressWarnings("null") public RedisSession getSession(int sessionType) { boolean isReload = false; long now = System.currentTimeMillis(); RedisSession session = null; Cache cache = Redis.use(); if (sessionId == null) { Cookie[] cookies = getRequest().getCookies(); if (cookies != null) { for (Cookie cookie : cookies) { if (cookie.getName().equals("JSESSIONID")) {//查看请求中是否有对应的Cookie记录 sessionId = cookie.getValue();//本地记录此次请求的sessionId，防止在初次请求时后台多次获取session，获取的session均不同 } } } } if (sessionId != null) { session = cache.get(sessionId);//如果有，从redis中取出对应的Session if (session != null) { if (session.getType() == RedisSession.SessionType.BROWSER) { session.setDestroyTime(now + RedisSession.SessionType.BROWSER.getValue());//若会话类型为浏览器则刷新其会话有效期 isReload = true; logger.info("刷新会话时间，JSESSIONID：" + session.getId() + "，延长：" + RedisSession.SessionType.BROWSER.getValue()/1000/60/60.0 + "小时"); } if (session.getDestroyTime() &lt; now) {//若会话过期，从redis中删除 cache.del(session.getId()); session = null; logger.info("删除过期会话，JSESSIONID：" + session.getId()); } } } if (session == null) { session = new RedisSession(sessionType);//若请求中没有对应Cookie记录，创建新的session sessionId = session.getId();//本地记录此次请求的sessionId，防止在初次请求时后台多次获取session，获取的session均不同 isReload = true; logger.info("创建新会话，JSESSIONID：" + session.getId() + "，有效时间：" + (session.getDestroyTime() - now)/1000/60/60.0 + "小时"); } if (isReload) {//session生命周期发生变化，需要重新redis中存储数据 cache.set(session.getId(), session);//将session存入redis中 cache.pexpire(session.getId(), session.getDestroyTime() - now);//设定redis数据储存有效期 } Cookie cookie = new Cookie("JSESSIONID", session.getId()); cookie.setPath("/"); cookie.setHttpOnly(true); getResponse().addCookie(cookie);//将cookie返回 return session; } } 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 说明： 以上代码中，设想服务器给移动端和网页端同时提供服务，为了优化，但我希望移动端不需要频繁登录，就像微信一样，我将这个时间暂设一周；而网页端的话，session生存周期较短，只有半个小时，并且每次鉴权都刷新其可用时间，移动端只倒计时就可以了，一周登录一次就可以了。redis自带有过期策略，可以很好的实现这一点，同时为了保险起见，也手动验证了一下如过期，进行删除。为了避免初次请求时，多次调用getSession()生成多个session，故在创建session成功后记录其sessionId，再次调用getSession()时可对其进行验证。 七、结果测试 1.在Controller中编写两个接口，一为登录接口，登录成功，储存用户uid；二为验证登录接口，获取登录信息： public void redisLogin() { RedisSession session = getSession(RedisSession.SessionType.BROWSER.getType()); session.setAttribute("uid", 1); renderText("登录成功，sessionId：" + session.getId()); } public void redisCheckLogin() { RedisSession session = getSession(RedisSession.SessionType.BROWSER.getType()); int uid = (int) session.getAttribute("uid"); renderText("sessionId：" + session.getId() + ", uid: " + uid); }123456789101112 2.配置nginx分别跳转到不同tomcat下的不同接口 #测试登录接口跳到8080 location = /tomcat1 { proxy_pass http://localhost:8080/mate/test/redisLogin; } #校验登录接口跳到8081 location = /tomcat2 { proxy_pass http://localhost:8081/mate/test/redisCheckLogin; }123456789 3.开启redis，nginx，两个tomcat下运行同样的项目，在浏览器中调用接口进行测试。 调用tomcat1的登录接口 日志： 调用tomcat2的登录接口 日志： 可以看到，两个tomcat中的信息完全一样，很好的达到了我们预计的效果。 到这里，本篇的内容也已经到了尾声，写的有点啰嗦，不过总算交代了来龙去脉，虽然有点累，但好歹写完了。未来还有很多工作要做，路漫漫其修远兮，吾将上下而求索。&lt;/ p&gt; &lt;/ div&gt; &lt;/ div&gt;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Struts2]]></title>
    <url>%2F2015%2F12%2F17%2Fstruts2%2F</url>
    <content type="text"><![CDATA[Struts2一、框架概述什么是框架，为什么使用框架，框架优点框架（framework）是一个基本概念上的结构，用于去解决或者处理复杂的问题框架，即framework。其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。框架是在特定的领域内解决问题。优点重用代码大大增加，软件生产效率和质量也得到了提高使用框架开发，它提供统一的标准，大大降低了我们的后期维护。学习框架重点:了解框架做了什么，我们要在这个基础上在做什么事情。 二、java开发中常用框架SSH (SSM SSI)SSH struts2 spring hibernateSSM(SSI) springmvc spring mybatis(ibatis) SSH 它是企业开发中比较主流的一套架构。SSH框架在开发中所处的位置: 三、Struts2框架介绍什么是struts2框架，学习struts2框架的核心。Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互Struts2=struts1+webwork 问题:struts2是一个mvc框架，它的mvc是什么? javaweb开发中的mvc,是在jsp的model2模式中提过Model——javabeanView——–jspController—-servlet 核心点:1.拦截器 interceptor2.Action3.ognl与valueStack 在现在开发中与struts2比较类似的框架有哪些?Struts1 webwork springmvc jsf Struts2框架流程 四、Struts2框架执行流程1．Struts2源码导入 对于struts2框架它的源代码我们主要使用三部分1.struts2核心部分源代码 org.apache.struts2xxsrc\core\src\main\java2.struts2的xwork核心部分源代码src\xwork-core\src\main\java\com\opensymphony\xwork23.struts2的插件的源代码src\plugins2．关于struts.xml配置文件中提示问题第一步在eclipse的window下首选面中查找xml catalog第二步Location:配置本地的dtd文件路径key type:选择URIKey: http://struts.apache.org/dtds/struts-2.3.dtd注意版本要对应，如果你可以上网，那么会自动缓存dtd,具有提示功能。 3．执行流程介绍1.当通过浏览器发送一个请求2.会被StrutsPrepareAndExecuteFilter拦截3.会调用strtus2框架默认的拦截器(interceptor)完成部分功能4.在执行Action中操作5.根据Action中方法的执行结果来选择来跳转页面Resutl视图 一般管StrutsPrepareAndExecuteFilter 叫做前端控制器(核心控制器)，只有配置了这个filter我们的strtus2框架才能使用。Strtus2的默认拦截器(interceptor)它们是在struts-default.xml文件中配置注意:这上xml文件是在strtus-core.jar包中。默认的拦截器是在defaultStack中定义的。 五、Struts2配置详解1．Struts2配置文件加载顺序 第一个加载的是default.properties文件位置:strtus2-core.jar包 org.apache.struts2包下作用:主要是声明了struts2框架的常量第二个加载的是一批配置文件Strtus-default.xml位置:struts2-corl.jar作用:声明了interceptor result beanStrtus-plugin.xml位置:在strtus2的插件包中作用:主要用于插件的配置声明Strtus.xml位置:在我们自己的工程中作用:用于我们自己工程使用strtus2框架的配置第三个加载的是自定义的strtus.properties位置:都是在自己工程的src下作用:定制常量第四自定义配置提供第五加载的是web.xml配置文件主要是加载strtus2框架在web.xml文件中的相关配置.第六 bean相关配置 重点掌握:1.Default.properties2.Struts-default.xml3.Struts-plugin.xml4.Strtus.xml5.web.xml 2．struts.xml文件配置介绍2.1．package配置1.name属性 作用:定义一个包的名称，它必须唯一。2.namespace属性 作用:主要是与action标签的name属性联合使用来确定一个action 的访问路径3.extends属性 作用:指定继承自哪个包。一般值是strtus-default strtus-default包是在strtus-default.xml文件中声明的。4.abstruct属性 它代表当前包是一个抽象的，主要是用于被继承2.2．action配置1.name属性 作用:主要是与package的namespace联合使用来确定一个action的访问路 径2.class属性 作用:用于指示当前的action类3.method属性 作用:用于指示当前的action类中的哪个方法执行2.3．result配置它主要是用于指示结果视图1.name属性 作用是与action类的method方法的返回值进行匹配，来确定跳转路径2.type属性 作用是用于指定跳转方式2.4．扩展关于action配置中的class与method的默认值以及result中的name与type 默认值问题 原因:strtus-default.xml文件中配置 它的作用就是当一个请求来时，如果查找不到指定的class及对应的method就会执行ActionSupport类中的execute方法。在这个类的execute方法中默认返回的是”success”也就是说，result的name属性默认值是success,默认的跳转方式是请求转发 dispatcher 3．常量配置default.properties文件中定义了struts2框架常用常量 .问题:我们怎样可以定义常量1.可以在src下创建一个strtus.properties配置文件2.可以在web.xml文件中配置3.可以直接在strtus.xml文件中定义常量 (推荐) 注意:后加载的配置文件中的常量会将先加载的常量覆盖 六、Struts2的Action详解Struts2中的action，主要是完成业务逻辑操作。Action替代在servlet中完成的作用。Action的学习主要有两点1.如何创建一个struts2的action2.如果访问一个struts2的action 1．Action类创建方式(三种)1.创建一个pojo类Pojo(plani Ordinary java object)简单的java对象Pojo类就是没有实现任何接口没有继承任何类优点:无耦合缺点:所有的功能都要自己完成 2.创建一个类实现一个Action接口com.opensymphony.xwork2.Action 在Action接口中定义了五个常量，一个execute方法五个常量:它们是默认的五个结果视图:ERROR : 错误视图INPUT: 它是struts2框架中interceptor中发现问题后会访问的一个视图LOGIN:它是一个登录视图，可以在权限操作中使用NONE:它代表的是null,什么都不做（也不会做跳转操作）SUCCESS:这是一个成功视图优点：耦合度低缺点:还是需要自己来完成功能 3.创建一个类继承ActionSupport类com.opensymphony.xwork2.ActionSupportActionSupport类也实现了Action接口。我们在开发中一般会使用这种方案:优点:具有丰富的功能，例如 表单校验 错误信息设置 国际化缺点:耦合度高2．action的访问方式1.直接通过标签来配置，通过method来指定访问的方法，如果method没有，默认访问的是execute方法。2.简化的action访问方式，可以使用通配符来访问。这种方式的缺点:不建议使用过多的号，它带来程序阅读障碍，不便于理解使用*来简化操作方案，它对名称规范必须进行一个统一。 3．扩展–动态方法调用 这是strtus2提供的动态方法调用。 注意:对于strtus2的动态方法调用，要想使用我们必须配置一个常量来开启动态方法调用 这代表动态方法调用没有开启 个人不建议使用动态方法调用 七、Struts2框架封装数据主要解决的问题:是在action中如果获取请求参数 主要有两种方式:1.属性驱动a.直接在action类中提供与请求参数匹配属性，提供get/set方法b.在action类中创始一个javaBean,对其提供get/set ，在请求时页面上要进行修改， 例如 user.username user.password ,要使用ognl表达式以上两种方式的优缺点:第一种比较简单，在实际操作我们需要将action的属性在赋值给模型(javaBean) 去操作 第二种:不需要在直接将值给javaBean过程，因为直接将数据封装到了javaBean 中。它要求在页面上必须使用ognl表达式，就存在页面不通用问题。 2.模型驱动步骤:1.让Action类要实现一个指定接口ModelDriven2.实例化模型对象(就是要new出来javaBean)3.重写getModel方法将实例化的模型返回。 对于模型驱动它与属性驱动对比，在实际开发中使用比较多，模型驱动缺点，它只能对 一个模型数据进行封装。 八、总结1.关于strtus2框架的环境搭建2.关于strtus2框架配置3.关于strtus2框架请求参数封装4.关于strtus2框架的路径跳转 关于action访问的配置 路径 关于路径跳转问题:是通过来配置跳转的路径.它的name属性是与action中的方法的返回值进行对比的。它的type属性可以取哪些值? 默认值是dispatcher 它代表的是请求转发。针对于jsp页面redirect 它代表的是重定向 针对于jsp页面chain 它类似于请示转发，只不过它是针对于action跳转.redirectAction 它类似于重定向 针对于action关于路径跳转的配置可以直接在下创建全局的result]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Struts2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器插件的使用教程]]></title>
    <url>%2F2015%2F09%2F23%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浏览器插件的使用教程安装油猴插架 [下载安装][http://www.tampermonkey.net] 选择和你浏览器对应的插架，如下图 安装成功后可以在浏览器插件（扩展）中看到油猴，如下图 使用油猴安装插件 点击油猴图标可以打开油猴的控制面板，如下图 点击[获取新脚本][http://tampermonkey.net/scripts.php] 选择脚本网站，推荐使用GreasyFork 选择要安装的脚本 在首页点击脚本列表 选择你需要的脚本点击安装 点击进行安装，如下图 安装成功后可以在油猴面板查看 插件可根据自己的需求安装，在脚本列表中可以看到很多有意思的插件 举例：查看VIP视频 安装VIP视频在线解析插件 打开视频网站，播放视频，可看到插件，如下图 解析VIP 视频的插件很多，选一个可以用的即可，也可以安装多个插件的作用只是]]></content>
      <categories>
        <category>Life</category>
      </categories>
      <tags>
        <tag>浏览器插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2015%2F09%2F21%2FLinux%2F</url>
    <content type="text"><![CDATA[Linux学习初学者必备 Linux常用命令 01-Linux的简介.avi什么是LinuxLinux是基于Unix的,是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux的应用服务器系统: Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等嵌入式系统: 路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等高性能运算、计算密集型应用 Linux有强大的运算能力桌面应用系统移动手持系统Linux的主流版本Ubuntu, Centos, redhat, fedora, freebsd… 02-虚拟软件的安装.avi安装参考《虚拟软件vmware安装.doc》 03-CentOS的安装.avi参考《CentOS6详细安装文档.doc》 04-Linux的目录结构.avi 05-Linux的常用命令：cd命令.avi==切换目录==cd app 切换到app目录cd .. 切换到上一层目录cd / 切换到系统根目录cd ~ 切换到用户主目录cd - 切换到上一个所在目录 06-Linux的常用命令：ls、ll、dir命令.avi==列出文件列表==ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容格式：ls[参数] [路径或文件名] 在linux中以 . 开头的文件都是隐藏的文件lsls -a 显示所有文件或目录（包含隐藏的文件）ls -l 缩写成ll 07-Linux的常用命令：mkdir、rmdir命令.avi==创建目录==mkdir app 在当前目录下创建app目录mkdir –p app2/test 级联创建aap2以及test目==移除目录==rmdir(remove directory)命令可用来删除“空”的子目录rmdir app 删除app目录 08-Linux的常用命令：cat、more、less、tail命令.avi浏览文件 cat 用于显示文件的内容格式：cat[参数]&lt;文件名&gt;cat yum.conf more 一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。回车显示下一行内容。按 q 键退出查看。more yum.conf 空格显示下一页数据 回车显示下一行的数据 less 用法和more类似，不同的是less可以通过PgUp、PgDn键来控制less yum.conf PgUp 和 PgDn 进行上下翻页. tail命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。==tail -10 /etc/passwd 查看后10行数据==tail -f catalina.log ==动态查看日志==ctrl+c 结束查看 09-Linux的常用命令：rm命令.avi==文件删除操作==rm 删除文件rm a.txt 删除a.txt文件删除需要用户确认，y/n rm 删除不询问rm -f a.txt 不询问，直接删除 rm 删除目录rm -r a 递归删除不询问递归删除（慎用）rm -rf a 不询问递归删除rm -rf * 删除所有文件rm -rf /* 自杀 10-Linux的远程连接：CRT的软件的安装和使用.avi11-Linux的常用命令：cp、mv命令.avi文件的拷贝和剪切cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。cp a.txt b.txt 将a.txt复制为b.txt文件cp a.txt ../ 将a.txt文件复制到上一层目录中 mv 移动或者重命名mv a.txt ../ 将a.txt文件移动到上一层目录中mv a.txt b.txt 将a.txt文件重命名为b.txt 12-Linux的常用命令：tar命令.avi==打包或者解压==tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。常用参数：-c:创建一个新tar文件-v:显示运行过程的信息-f:指定文件名-z:调用gzip压缩命令进行压缩-t:查看压缩文件的内容-x:解开tar文件 ==打包==tar –cvf xxx.tar ./*打包并且压缩：tar –zcvf xxx.tar.gz ./* ==解压==tar –xvf xxx.tartar -xvf xxx.tar.gz -C /usr/aaa 13-Linux的常用命令：grep命令.avigrep命令查找符合条件的字符串用法: grep [选项]… PATTERN [FILE]…示例：grep lang anaconda-ks.cfg 在文件中查找langgrep lang anaconda-ks.cfg –color 高亮显示 14-Linux的常用命令：其他常用命令.avi其他常用命令pwd 显示当前所在目录touch 创建一个空文件touch a.txtll -h 友好显示文件大小wget 下载资料 wget http://nginx.org/download/nginx-1.9.12.tar.gz 15-Linux的常用命令：VI和VIM编辑器.avi==Vi和Vim编辑器==在Linux下一般使用vi编辑器来编辑文件vi既可以查看文件也可以编辑文件三种模式：命令行、插入、底行模式切换到命令行模式：按Esc键切换到插入模式：按 i 、o、a键i 在当前位置生前插入I 在当前行首插入a 在当前位置后插入A 在当前行尾插入o 在当前行之后插入一行O 在当前行之前插入一行 切换到底行模式：按 :（冒号） 打开文件：vim file退出：esc :q修改文件：输入i进入插入模式保存并退出：esc :wq不保存退出：esc :q! 16-Linux的常用命令：重定向输出.avi&gt; 重定向输出，覆盖原有内容&gt;&gt; 重定向输出，又追加功能 cat /etc/passwd &gt; a.txt 将输出定向到a.txt中cat /etc/passwd &gt;&gt; a.txt 输出并且追加 ifconfig &gt; ifconfig.txt 17-Linux的常用命令：管道和命令执行控制.avi管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入 ls --help | more 分页查询帮助信息ps –ef | grep java 查询名称中包含java的进程ifconfig | morecat index.html | moreps –ef | grep aio 命令控制命令之间使用 &amp;&amp; 连接，实现逻辑与的功能只有在 &amp;&amp; 左边的命令返回真,&amp;&amp; 右边的命令才会被执行只要有一个命令返回假,后面的命令就不会被执行。mkdir test &amp;&amp; cd test 18-Linux的常用命令：网络通讯的命令.avi网络通讯命令ifconfig 显示或设置网络设备ifconfig eth0 up 启用eth0网卡ifconfig eth0 down 停用eth0网卡 ping 探测网络是否通畅。ping 192.168.0.1 netstat 查看网络端口。netstat -an | grep 3306 查询3306端口占用情况 19-Linux的常用命令：系统管理的命令.avi系统管理命令date 显示或设置系统时间date 显示当前系统时间date -s “2014-01-01 10:10:10“ 设置系统时间 df 显示磁盘信息df –h 友好显示大小 free 显示内存状态free –m 以mb单位显示内存组昂头 top 显示，管理执行中的程序 clear 清屏幕ps 正在运行的某个进程的状态ps –ef 查看所有进程ps –ef | grep ssh 查找某一进程 kill 杀掉某一进程kill 2868 杀掉2868编号的进程kill -9 2868 强制杀死进程 du 显示目录或文件的大小du –h 显示当前目录的大小who 显示目前登入系统的用户信息hostname 查看当前主机名修改：vi /etc/sysconfig/networkuname 显示系统信息。uname -a 显示本机详细信息依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称 20-Linux的常用命令：用户管理的命令.avi用户管理命令useradd 添加一个用户useradd test 添加test用户useradd test -d /home/t1 指定用户home目录passwd 设置、修改密码passwd test 为test用户设置密码 切换登录：ssh -l test -p 22 192.168.19.128su – 用户名userdel 删除一个用户userdel test 删除test用户(不会删除home目录)userdel –r test 删除用户以及home目录 21-Linux的常用命令：组管理的命令.avi组管理命令当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组创建用户时也可以指定所在组groupadd 创建组groupadd public 创建一个名为public的组useradd u1 –g public 创建用户指定组 groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。groupdel public 22-Linux的常用命令：权限管理.avi文件权限变更文件权限chmod 变更文件或目录的权限。chmod 755 a.txtchmod u=rwx,g=rx,o=rx a.txtchmod 000 a.txt / chmod 777 a.txt chown ==变更文件或目录改文件所属用户和组==chown u1:public a.txt ：变更当前的目录或文件的所属用户和组chown -R u1:public dir ：变更目录中的所有的子目录及文件的所属用户和组]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
</search>
