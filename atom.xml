<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>wjlfun.info</title>
  
  <subtitle>云飞扬的个人博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wjlfun.info/"/>
  <updated>2018-04-16T01:06:45.501Z</updated>
  <id>http://wjlfun.info/</id>
  
  <author>
    <name>吴金龙</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>spring</title>
    <link href="http://wjlfun.info/2016/05/07/spring+springmvc+shiro%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <id>http://wjlfun.info/2016/05/07/spring+springmvc+shiro面试题总结/</id>
    <published>2016-05-06T16:00:00.000Z</published>
    <updated>2018-04-16T01:06:45.501Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><p>  这些Spring面试题是从尚硅谷<a href="http://www.atguigu.com的JavaEE面试题整理出来的，希望对你有帮助！" target="_blank" rel="noopener">http://www.atguigu.com的JavaEE面试题整理出来的，希望对你有帮助！</a></p><ol><li>开发中主要使用 Spring 的什么技术 ?<br>①. IOC 容器管理各层的组件<br>②. 使用 AOP 配置声明式事务<br>③. 整合其他框架.</li></ol><ol><li>简述 AOP 和 IOC 概念<br>AOP: Aspect Oriented Program, 面向(方面)切面的编程;Filter(过滤器)也是一种   AOP.  AOP  是一种新的方法论 ,  是对传统   OOP(Object-Oriented Programming, 面向对象编程) 的补充. AOP 的主要编程对像是切面(aspect), 而切面模块化横切关注点.可以举例通过事务说明.<br>IOC: Invert Of Control, 控制反转. 也成为 DI(依赖注入)其思想是反转资源获取的方向. 传统的资源查找方式要求组件向容器发起请求查找资源.作为回应, 容器适时的返回资源. 而应用了 IOC 之后, 则是容器主动地将资源推送给它所管理的组件,组件所要做的仅是选择一种合适的方式来接受资源. 这种行为也被称为查找的被动形式.</li></ol><ol><li>在 Spring 中如何配置 Bean ?<br>Bean 的配置方式: 通过全类名 （反射）、 通过工厂方法 （静态工厂方法 &amp; 实例工厂方法）、FactoryBean</li></ol><ol><li>IOC 容器对 Bean 的生命周期:<br>①. 通过构造器或工厂方法创建 Bean 实例<br>②. 为 Bean 的属性设置值和对其他 Bean 的引用<br>③. 将Bean实例传递给Bean后置处理器的postProcessBeforeInitialization 方法<br>④. 调用 Bean 的初始化方法(init-method)<br>⑤. 将Bean实例传递给Bean后置处理器的postProcessAfterInitialization 方法<br>⑦. Bean 可以使用了<br>⑧. 当容器关闭时, 调用 Bean 的销毁方法(destroy-method)</li></ol><ol><li><p>说一下struts2-hibernate-Spring 的工作流程？</p><p>1). Struts2 负责显示页面和接受请求<br>2). Spring 的 IOC 容器管理各个组件: 整合 Struts2，Hibernate 和 其他组件，AOP 完成声明式事务<br>3). Hibernate 提供 DAO 操作.</p></li><li><p>Spring 如何整合 Struts2 ?</p><p>整合 Struts2, 即由 IOC 容器管理 Struts2 的 Action:</p><blockquote><p>安装 Spring 插件: 把 struts2-spring-plugin-2.2.1.jar 复制到<br>当前 WEB 应用的 WEB-INF/lib 目录下<br>在 Spring 的配置文件中配置 Struts2 的 Action 实例<br>在 Struts 配置文件中配置 action,  但其 class 属性不再指向该Action 的实现类, 而是指向 Spring 容器中 Action 实例的 ID</p></blockquote></li></ol><ol><li>Spring 如何整合 Hibernate<br>整合  Hibernate,  即由  IOC  容器生成  SessionFactory  对象,  并使用Spring 的声明式事务<blockquote><p>利用 LocalSessionFactoryBean 工厂 Bean, 声明一个使用 XML 映射文件的 SessionFactory 实例.<br>利用 HibernateTransactionManager 配置 Hibernate 的事务管理器</p></blockquote></li></ol><ol><li>Spring MVC 比较 Struts2<br>①. Spring MVC 的入口是 Servlet, 而 Struts2 是 Filter<br>②. Spring MVC 会稍微比 Struts2 快些. Spring MVC 是基于方法设计, 而 Sturts2 是基于类, 每次发一次请求都会实例一个 Action.<br>③. Spring MVC 使用更加简洁, 开发效率 Spring MVC 确实比 struts2 高: 支持 JSR303, 处理 ajax 的请求更方便<br>④. Struts2 的 OGNL 表达式使页面的开发效率相比 Spring MVC 更高些. </li></ol><ol><li>Spring MVC 的运行流程<br>①. 在整个 Spring MVC 框架中， DispatcherServlet 处于核心位置，负责协调和组织不同组件以完成请求处理并返回响应的工作<br>②. SpringMVC 处理请求过程：<blockquote><p> 若一个请求匹配  DispatcherServlet 的请求映射路径(在  web.xml 中指定), WEB 容器将该请求转交给 DispatcherServlet 处理<br>DispatcherServlet 接收到请求后, 将根据请求信息(包括 URL、 HTTP 方法、 请求头、 请求参数、 Cookie 等)及 HandlerMapping 的配置找到处理请求的处理器(Handler). 可将 HandlerMapping 看成路由控制器， 将 Handler 看成目标主机。<br>当 DispatcherServlet 根据 HandlerMapping 得到对应当前请求的Handler 后，通过 HandlerAdapter 对 Handler 进行封装，再以统一的适配器接口调用 Handler。<br> 处 理 器 完 成 业 务 逻 辑 的 处 理 后 将 返 回 一 个   ModelAndView  给DispatcherServlet, ModelAndView 包含了视图逻辑名和模型数据信息<br>DispatcherServlet 借助 ViewResoler 完成逻辑视图名到真实视图对象的解析<br>得到真实视图对象 View 后, DispatcherServlet 使用这个 View 对ModelAndView 中的模型数据进行视图渲染<br><a href="https://blog.verysu.com/resources/upload/image/20141129/20141129145306_762.png" target="_blank" rel="noopener">https://blog.verysu.com/resources/upload/image/20141129/20141129145306_762.png</a></p></blockquote></li></ol><ol><li>说出 Spring MVC 常用的 5 个注解:<br>@RequestMapping 、 @PathVariable 、 @RequestParam 、 @RequestBoy 、@ResponseBody</li></ol><ol><li>如何使用 SpringMVC 完成 JSON 操作：<br>①. 配置 MappingJacksonHttpMessageConverter<br>②. 使用 @RequestBody 注解或 ResponseEntity 作为返回值</li></ol><ol><li><p>比较 SpringSecurity 和 Shiro</p><p>相比 Spring Security, Shiro 在保持强大功能的同时, 使用简单性和灵活性</p><blockquote><p>SpringSecurity: 即使是一个一个简单的请求，最少得经过它的 8 个Filter<br>SpringSecurity 必须在 Spring 的环境下使用<br>初学 Spring Security, 曲线还是较大, 需要深入学习其源码和框架, 配置起来也较费力.</p></blockquote></li></ol><ol><li><p>Shiro 的优点</p><blockquote><p>简单的身份认证, 支持多种数据源<br>对角色的简单的授权, 支持细粒度的授权(方法级)<br>支持一级缓存，以提升应用程序的性能；<br>内置的基于 POJO 企业会话管理, 适用于 Web 以及非 Web 的环境<br>非常简单的加密 API<br>不跟任何的框架或者容器捆绑, 可以独立运行</p></blockquote></li></ol><ol><li><p>简述 Shiro 的核心组件</p><p>Shiro 架构 3 个核心组件:</p><blockquote><p>Subject: 正与系统进行交互的人, 或某一个第三方服务.<br>所有 Subject 实例都被绑定到（且这是必须的）一个SecurityManager 上。<br>SecurityManager: Shiro 架构的心脏, 用来协调内部各安全组件, 管理内部组件实例, 并通过它来提供安全管理的各种服务.<br>当 Shiro 与一个 Subject 进行交互时, 实质上是幕后的 SecurityManager 处理所有繁重的 Subject 安全操作。<br>Realms: 本质上是一个特定安全的 DAO. 当配置 Shiro 时, 必须指定至少一个 Realm 用来进行身份验证和/或授权.<br>Shiro 提供了多种可用的 Realms 来获取安全相关的数据. 如关系数据库(JDBC), INI 及属性文件等.<br>可以定义自己 Realm 实现来代表自定义的数据源。</p></blockquote></li><li><p>Shiro认证过程</p><p>①. 应用程序代码调用 Subject.login 方法，传递创建好的包含终端用户的 Principals(身份)和 Credentials(凭证)的 AuthenticationToken 实例<br>②. Subject 实例: 通常为 DelegatingSubject(或子类)委托应用程序的 SecurityManager 通过调用securityManager.login(token) 开始真正的验证。<br>③. SubjectManager 接收 token，调用内部的 Authenticator 实例调用 authenticator.authenticate(token).Authenticator 通常是一个 ModularRealmAuthenticator 实例, 支持在身份验证中协调一个或多个Realm 实例<br>④. 如果应用程序中配置了一个以上的 Realm, ModularRealmAuthenticator 实例将利用配置好的AuthenticationStrategy 来启动 Multi-Realm 认证尝试. 在Realms 被身份验证调用之前, 期间和以后,AuthenticationStrategy 被调用使其能够对每个Realm 的结果作出反应.<br>⑤. 每个配置的 Realm 用来帮助看它是否支持提交的 AuthenticationToken. 如果支持, 那么支持 Realm 的 getAuthenticationInfo 方法将会伴随着提交的 token 被调用. getAuthenticationInfo 方法有效地代表一个特定 Realm 的单一的身份验证尝试。</p></li></ol><p><a href="https://blog.verysu.com/resources/upload/image/20141129/20141129150045_776.png" target="_blank" rel="noopener">https://blog.verysu.com/resources/upload/image/20141129/20141129150045_776.png</a></p><ol><li><p>Shiro授权过程</p><p>①. 应用程序或框架代码调用任何 Subject 的hasRole<em>, checkRole</em>, isPermitted<em>,或者checkPermission</em>方法的变体, 传递任何所需的权限<br>②. Subject 的实例—通常是 DelegatingSubject(或子类), 调用securityManager 的对应的方法.<br>③. SecurityManager 调用 org.apache.shiro.authz.Authorizer 接口的对应方法.默认情况下，authorizer 实例是一个 ModularRealmAuthorizer 实例, 它支持协调任何授权操作过程中的一个或多个Realm 实例<br>④. 每个配置好的 Realm 被检查是否实现了相同的 Authorizer 接口. 如果是, Realm 各自的 hasRole<em>, checkRole</em>,isPermitted<em>，或 checkPermission</em> 方法将被调用。</p></li></ol><p><a href="https://blog.verysu.com/resources/upload/image/20141129/20141129145938_946.png" target="_blank" rel="noopener">https://blog.verysu.com/resources/upload/image/20141129/20141129145938_946.png</a></p><ol><li><p>Shiro 如何自实现认证</p><p>Shiro 的认证过程由 Realm 执行, SecurityManager 会调用 org.apache.shiro.realm.Realm 的 getAuthenticationInfo(AuthenticationToken token) 方法. 实际开发中, 通常提供 org.apache.shiro.realm.AuthenticatingRealm 的实现类, 并在该实现类中提供 doGetAuthenticationInfo(AuthenticationToken token)方法的具体实现</p></li><li><p>如何实现自实现授权</p><p>实际开发中, 通常提供  org.apache.shiro.realm.AuthorizingRealm 的实现类,<br>并提供 doGetAuthorizationInfo(PrincipalCollection principals) 方法的具体实现</p></li><li><p>如何配置在 Spring 中配置使用 Shiro</p><p>①. 在 web.xml 中配置 Shiro 的 Filter<br>②. 在 Spring 的配置文件中配置  Shiro:</p><blockquote><p>配置自定义 Realm：实现自定义认证和授权<br>配置 Shiro 实体类使用的缓存策略<br>配置 SecurityManager<br>配置保证 Shiro 内部 Bean 声明周期都得到执行的 Lifecycle Bean 后置处理器<br>配置AOP 式方法级权限检查<br>配置 Shiro Filter</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h2 id=&quot;面试题&quot;&gt;&lt;a href=&quot;#面试题&quot; class=&quot;headerlink&quot; title=&quot;面试题&quot;&gt;&lt;/a&gt;面试题&lt;/h2&gt;&lt;p&gt;  这些Spring面试题是从尚
      
    
    </summary>
    
      <category term="Java" scheme="http://wjlfun.info/categories/Java/"/>
    
    
      <category term="spring" scheme="http://wjlfun.info/tags/spring/"/>
    
  </entry>
  
  <entry>
    <title>集群间实现session共享</title>
    <link href="http://wjlfun.info/2016/04/17/%E9%9B%86%E7%BE%A4%E9%97%B4%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/"/>
    <id>http://wjlfun.info/2016/04/17/集群间实现session共享/</id>
    <published>2016-04-16T16:00:00.000Z</published>
    <updated>2018-05-15T07:02:50.534Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><p><div id="article_content" class="article_content csdn-tracking-statistics" data-pid="blog" data-mod="popu_307" data-dsm="post"><br>                    <div class="markdown_views"></div></div></p><h2 id="一引言"><a name="t0"></a>一、引言</h2><p>针对企业，为了应对庞大的用户访问压力，目前大多数大型网站服务器都采用集群部署的方式；针对个人，仅一台服务器而言，也会安装多个tomcat进行错时更新，保证更新后台业务时服务不断开，即模拟了集群的运行方式。在此集群中，我们就不得不考虑一个用户鉴权的问题，即在不同服务上如何保证用户均已登录，并能获取相同的用户登录信息。</p><h2 id="二java-web推荐的公认的用户鉴权机制"><a name="t1"></a>二、Java Web推荐的（公认的）用户鉴权机制</h2><p>说此部分之前先了解几个概念： <br><br>1.请求，即Request，指客户端向服务器发送的信息，通常是通信的发起方； <br><br>2.响应，即Response，指服务器对请求的应答，通常是通信的回复方； <br><br>3.会话，即Session，服务器可将请求&lt;-&gt;响应这一个完整的过程称为一次会话，并为这次会话生成一个唯一的标识符，即sessionId，用来表示这次会话，Session储存在服务器端； <br><br>4.Cookie，客户端保存在本地终端的数据，即Cookie储存在客户端。</p><p>Java Web的共用的用户鉴权机制是采用Session-Cookie技术，实现原理是：用户登录时，请求到达服务器，服务器调用通过getSession()方法判断session是否存在，如果不存在，则新建session，并通过其算法为session生成一个随机数作为sessionId，开发者可在session中储存一些用户信息；第二次请求时，如获取用户信息，getSession()方法判断session存在，则取出session，而不是新建，从而从session中获取到用户的相关信息。</p><p>客户端请求时，可以将cookie信息储存于request的head中发送给服务器； <br><br>服务器响应时，可以将cookie信息置于response中回传给客户端。 <br><br>如下图代表，名称为test的cookie其值为aaa: <br><br><img src="https://img-blog.csdn.net/20170824164825799?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><p>那么getSession()里究竟做了什么？</p><p>1.第一次用户请求，客户端本地没有任何数据，即其cookie为空，朝服务器发送request，getSession()中会解析request,发现其约定的cookie为null，则认为没有session，所以会重新创建一个session对象；</p><p>2.创建session后会将此session的id放入response中，回传给客户端，客户端则保存response中的cookie；</p><p>3.再次请求，服务器getSession()又会重新解析request获取cookie，发现了其中的sessionId，那么根据此sessionId去服务器的中去找，则得到了上次创建的session对象，那么则认为鉴权成功。</p><p>如此，便完成了鉴权的整个流程，Java逻辑代码(伪代码)如下：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs cs has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-keyword">public</span> HttpSession <span class="hljs-title">getSession</span>() {    <span class="hljs-comment">//从request中解析cookie</span>    HttpSession session = <span class="hljs-keyword">null</span>;    Cookie[] cookies = getRequest().getCookies();    <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>) {        <span class="hljs-keyword">for</span> (Cookie cookie : cookies) {            <span class="hljs-keyword">if</span> (cookie.getName().equals(<span class="hljs-string">"JSESSIONID"</span>)) {                String sessionId = cookie.getValue();                session = <span class="hljs-comment">//根据sessionId获取内存中的session对象</span>            }        }    }    <span class="hljs-keyword">if</span> (session == <span class="hljs-keyword">null</span>) {        session = <span class="hljs-comment">//创建一个新的session对象</span>    }    <span class="hljs-comment">//通过response将cookie返回</span>    Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"JSESSIONID"</span>, session.getId());    getResponse().addCookie(cookie);    <span class="hljs-keyword">return</span> session;}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li></ul></pre><p>如上，java中将sessionId在cookie中保存的名称叫做“JSESSIONID”，即“Java Session Id”之意，打开浏览器可以看到类型的信息，如图： <br><br><img src="https://img-blog.csdn.net/20170824165239731?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><h2 id="三集群间如何实现session共享"><a name="t2"></a>三、集群间如何实现session共享</h2><p>按照前文所说的session-cookie机制，session是保存在每台服务器的，但在集群中，拥有多台服务器，每台各自为政，势必会造成在这台服务器中登录，获取session成功，但是到另一台服务器上，又会获取不到session，造成鉴权失败，这样对用户来说是极不友好的，那么怎么解决这个问题呢？</p><p>通过我们以上的分析，即可得出几种处理方式: <br><br>A.找一块公共的空间用来储存session，而不是将session储存在集群节点的某台服务器上，此时，每一台服务器都能访问这块空间，从而实现session共享；</p><p>B.仍在每台服务器上保存session信息，不作修改，但采用另一种同步机制，实时同步没一台服务器的session信息；</p><p>C.构建一种全新的鉴权机制，不采用session-cookie机制，但要去除此鉴权机制对单个服务器的依赖。</p><p>综上所述，列举几种的具体实现方案：</p><hr><p>1.持久化session到数据库，即使用数据库来储存session。数据库正好是我们普遍使用的公共储存空间，一举两得，推荐使用mysql数据库，轻量并且性能良好。</p><p>优点：就地取材，符合大多数人的思维，使用简单，不需要太多额外编码工作 <br><br>缺点：对mysql性能要求较高，访问mysql需要从连接池中获取连接，又因为大部分请求均需要进行登录鉴权，所以操作数据库非常频繁，当用户量达到一定程度之后，极易造成数据库瓶颈，不适用于处理高并发的情况。</p><hr><p>2.使用redis共享session。redis是一个key-value的储存系统。可以简单的将其理解为一个数据库，与传统数据库的区别是，它将数据储存于内存中，并自带有内存到硬盘的序列化策略，即按策略将内存中的数据同步到磁盘，避免数据丢失，是目前比较流行的解决方案。</p><p>优点：无需增加数据库的压力，因为数据存储于内存中，所以读取非常快，高性能，并能处理多种类型的数据。 <br><br>缺点：额外增加一些编码，以便操作redis。</p><hr><p>3.使用memcache同步session，memcache可以实现分布式，可将服务器中的内存组合起来，形成一个“内存池”，以此充当公共空间，保存session信息。</p><p>优点：数据储存在内存中，读取非常快，性能好； <br><br>缺点：memcache把内存分成很多种规格的存储块，有大有小，不能完全利用内存，会产生内存碎片，浪费资源，如果储存块不足，还会产生内存溢出。</p><hr><p>4.通过脚本或守护进程在多台服务器之间同步session。</p><p>优点：实现了session共享； <br><br>缺点：对个人来说实现较为复杂，速度不稳定，有延时性，取决于现实中服务运行状态，偶然性较大，如果用于访问过快，可能出现session还没同步成功的情况。</p><hr><p>5.使用NFS共享session。NFS是Network File Server共享服务器的简称，最早由Sun公司为解决Unix网络主机间的目录共享而研发。选择一台公共的NFS做共享服务器，储存所有session数据，每台服务器所需的session均从此处获取。</p><p>优点：较好的实现了session共享； <br><br>缺点：成本较高，对于个人来说难以实现。NFS依托于复杂的安全机制和文件系统，因此并发效率不高。</p><hr><p>6.使用Cookie共享session。此方案可以说是独辟蹊径了，将分布式思想用到了极致。如上文分析所说，session-cookie机制中，session与cookie相互关联，以cookie做中转站，用来找到对应的session，其中session存放在服务器。那么如果将session中的内容存放在cookie中呢，那么则省略了服务器保存session的过程，后台只需要根据cookie中约定的标识进行鉴权校验即可。</p><p>优点：完美的贯彻分布式的理念，将每个用户都利用起来，无需耗费额外的服务器资源； <br><br>缺点：受http协议头长度限制，cookie中存储的信息不宜过多；为了保持cookie全局有效，所以其一般依赖在根域名下，所以基本上所有的http请求都需要传递cookie中的这些标记信息，所以会占用一些服务器的带宽；鉴权信息全存储于cookie中，cookie存在于客户端，服务器并没有储存相关信息，cookie存在着泄露的可能，或则其他人揣摩出规则后可以进行伪装，其安全性比其他方案差，故需要对cookie中信息进行加密解密，来增强其安全性。</p><hr><p>在此，我们将选择方案2使用redis来具体实现集群下的session共享。</p><h2 id="四搭建测试环境"><a name="t3"></a>四、搭建测试环境</h2><p>1.为模拟集群环境，需要两台服务器或在一台服务器上安装两个tomcat； <br><br>2.使用nginx做集群纷发； <br><br>3.安装redis充当公共的空间存储session; <br><br>4.框架中编写session储存业务，因为需要使用java操作redis，redis提供了驱动包jedis，故需要掌握jedis进行操作。</p><h2 id="五详细部署"><a name="t4"></a>五、详细部署</h2><p>5.1 安装多个tomcat <br><br>怎么安装tomcat此处不作说明，只说明安装额外的tomcat，本人原安装的tomcat目录为apache-tomcat-7.0.77</p><p>1.拷贝apache-tomcat-7.0.77为apache-tomcat-7.0.77_2 <br><br>2.修改apache-tomcat-7.0.77_2下conf中server.xml文件端口号 <br><br>，共三处，将每处在原端口号port之上加1，确保两个tomcat不会共用端口，如下：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs xml has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-tag">&lt;<span class="hljs-title">Server</span> <span class="hljs-attribute">port</span>=<span class="hljs-value">"8006"</span> <span class="hljs-attribute">shutdown</span>=<span class="hljs-value">"SHUTDOWN"</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">Connector</span> <span class="hljs-attribute">port</span>=<span class="hljs-value">"8081"</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-value">"HTTP/1.1"</span>               <span class="hljs-attribute">connectionTimeout</span>=<span class="hljs-value">"20000"</span>               <span class="hljs-attribute">redirectPort</span>=<span class="hljs-value">"8443"</span> /&gt;</span><span class="hljs-tag">&lt;<span class="hljs-title">Connector</span> <span class="hljs-attribute">port</span>=<span class="hljs-value">"8010"</span> <span class="hljs-attribute">protocol</span>=<span class="hljs-value">"AJP/1.3"</span> <span class="hljs-attribute">redirectPort</span>=<span class="hljs-value">"8443"</span> /&gt;</span></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre><p>5.2 更改nginx配置，模拟集群 <br><br>修改nginx配置文件nginx.conf文件，在server闭包外添加upstream，由上可知两个tomcat端口号分别为8080，8081</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs vala has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-preprocessor">#建立集群</span>upstream not_alone {    server localhost:<span class="hljs-number">8080</span>;    server localhost:<span class="hljs-number">8081</span>;}<span class="hljs-preprocessor"># 转发请求到tomcat下mate项目</span>location / {    proxy_pass http:<span class="hljs-comment">//not_alone/mate/; </span>}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre><p>5.2 redis安装与配置</p><p>1.下载，官网：<a href="https://redis.io/download" target="_blank">https://redis.io/download</a> <br><br>2.安装，以4.0.1版本为例</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs avrasm has-numbering" style="background-color: rgb(225, 230, 215);">$ wget http://download<span class="hljs-preprocessor">.redis</span><span class="hljs-preprocessor">.io</span>/releases/redis-<span class="hljs-number">4.0</span><span class="hljs-number">.1</span><span class="hljs-preprocessor">.tar</span><span class="hljs-preprocessor">.gz</span>$ tar xzf redis-<span class="hljs-number">4.0</span><span class="hljs-number">.1</span><span class="hljs-preprocessor">.tar</span><span class="hljs-preprocessor">.gz</span>$ cd redis-<span class="hljs-number">4.0</span><span class="hljs-number">.1</span>$ make</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li></ul></pre><p>3.启动</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs ruby has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-variable">$ </span>src/redis-server</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>4.关闭</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs  has-numbering" style="background-color: rgb(225, 230, 215);">ctrl + c</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>5.配置后台启动（redis默认是前台启动，启动成功后界面就持续停止在那个界面上，这对服务器操作很不方便） <br><br><img src="https://img-blog.csdn.net/20170824165844222?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs vala has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-preprocessor">#修改其配置文件</span>vim redis.conf将daemonize no改为daemonize yes<span class="hljs-preprocessor">#保存退出</span>:wq!</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li></ul></pre><p>如下图： <br><br><img src="https://img-blog.csdn.net/20170824170211245?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><p>6.后台启动</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs axapta has-numbering" style="background-color: rgb(225, 230, 215);">src/redis-<span class="hljs-keyword">server</span> redis.conf</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li></ul></pre><p>如图： <br><br><img src="https://img-blog.csdn.net/20170824170324744?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><p>7.关闭 <br><br>杀掉redis进程,如图： <br><br><img src="https://img-blog.csdn.net/20170824170437495?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><p>8.为redis配置系统服务，本人使用的系统是CentOS 7，需要配置使用systemctl进行管理。 <br><br>/lib/systemd/system目录下创建文件redis.service，并编辑：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs vala has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-preprocessor">#表示服务信息</span>[Service]Type=forking<span class="hljs-preprocessor">#注意：需要和redis.conf配置文件中的信息一致</span>PIDFile=/<span class="hljs-keyword">var</span>/run/redis_6379.pid<span class="hljs-preprocessor">#启动服务的命令</span><span class="hljs-preprocessor">#redis-server安装的路径 和 redis.conf配置文件的路径</span>ExecStart=/server/soft/redis-<span class="hljs-number">4.0</span><span class="hljs-number">.1</span>/src/redis-server /server/soft/redis-<span class="hljs-number">4.0</span><span class="hljs-number">.1</span>/redis.conf<span class="hljs-preprocessor">#重新加载命令</span>ExecReload=/bin/kill -s<span class="hljs-constant"> HUP </span>$MAINPID<span class="hljs-preprocessor">#停止服务的命令</span>ExecStop=/bin/kill -s<span class="hljs-constant"> QUIT </span>$MAINPIDPrivateTmp=<span class="hljs-literal">true</span><span class="hljs-preprocessor">#安装相关信息</span>[Install]<span class="hljs-preprocessor">#以哪种方式启动</span>WantedBy=multi-user.target<span class="hljs-preprocessor">#multi-user.target表明当系统以多用户方式（默认的运行级别）启动时，这个服务需要被自动运行。</span></code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li></ul></pre><p>更多redis systemctl详细配置，请看：<a href="http://blog.csdn.net/u011389474/article/details/72303156" target="_blank">http://blog.csdn.net/u011389474/article/details/72303156</a></p><p>配置成功，启动完成后，通过服务可知其运行状态，如图： <br><br><img src="https://img-blog.csdn.net/20170824170805702?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><p>至此，redis已全部安装部署完成。</p><h2 id="六编写代码实现功能"><a name="t5"></a>六、编写代码实现功能</h2><p>为了测试简便，后台web框架我选择的是JFinal，JFinal是中国开源社区中广受好评的后台轻量级极速web框架，因其操作简单，设计灵活而被大多数开发者所喜爱，有兴趣的朋友可以试试，用一次之后你就会喜欢它的，JFinal社区:<a href="http://www.jfinal.com/" target="_blank">http://www.jfinal.com/</a></p><p>这里用JFianl的另一个好处就是JFinal核心库中自带Redis插件，集成了jedis的各种使用方法，这样就不用自己去编写了，省了很大的代码量。Jedis基本操作：<a href="http://www.cnblogs.com/edisonfeng/p/3571870.html" target="_blank">http://www.cnblogs.com/edisonfeng/p/3571870.html</a></p><p>为帮助理解代码，Jfinal中连接redis，只需要在主配置文件中编写：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs java has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-javadoc">/** * 插件配置 */</span><span class="hljs-annotation">@Override</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configPlugin</span>(Plugins me) {    <span class="hljs-comment">/*    * Redis配置：连接本地的mate redis库，端口号默认    */</span>    RedisPlugin rp = <span class="hljs-keyword">new</span> RedisPlugin(<span class="hljs-string">"mate"</span>, <span class="hljs-string">"localhost"</span>);    me.add(rp);}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li></ul></pre><p>redis存取数据：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs lasso has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-keyword">Cache</span> <span class="hljs-keyword">cache</span> <span class="hljs-subst">=</span> Redis<span class="hljs-built_in">.</span>use();<span class="hljs-comment">//存</span><span class="hljs-keyword">cache</span><span class="hljs-built_in">.</span><span class="hljs-built_in">set</span>(key, value);<span class="hljs-comment">//取</span>Object value  <span class="hljs-subst">=</span> <span class="hljs-keyword">cache</span><span class="hljs-built_in">.</span>get(key);<span class="hljs-comment">//设置redis过期时间</span><span class="hljs-keyword">cache</span><span class="hljs-built_in">.</span>pexpire(key, time);</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li></ul></pre><p>正式代码如下，我们将会自定义session，每个sesison对象都是唯一的，需要给每个session分配一个唯一id，id生成算法，则可以借用UUID实现，UUID相关介绍：<a href="https://baike.baidu.com/item/UUID/5921266?fr=aladdin" target="_blank">https://baike.baidu.com/item/UUID/5921266?fr=aladdin</a> <br><br>自定义随机数工具类：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs java has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-javadoc">/** * 随机数工具类 *<span class="hljs-javadoctag"> @author</span> alone */</span><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomUtils</span> {</span>    <span class="hljs-javadoc">/**     * 获取唯一的可辨识资讯UUID     * UUID为128位二进制，每4位二进制=16进制，其添加了四个'-'，故总长为36位     *<span class="hljs-javadoctag"> @param</span> 是否删除标记     *<span class="hljs-javadoctag"> @return</span> UUID     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getUUID</span>(<span class="hljs-keyword">boolean</span> rmtag) {        String uuid = UUID.randomUUID().toString();        <span class="hljs-keyword">if</span> (rmtag) {            uuid = uuid.replace(<span class="hljs-string">"-"</span>, <span class="hljs-string">""</span>);        }        <span class="hljs-keyword">return</span> uuid;    }}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li></ul></pre><p>自定义RedisSession类，将替代原来的HttpSession：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs java has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-keyword">package</span> com.alone.mate.common;<span class="hljs-keyword">import</span> java.io.Serializable;<span class="hljs-keyword">import</span> java.util.HashMap;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> com.alone.mate.utils.RandomUtils;<span class="hljs-keyword">import</span> com.jfinal.plugin.redis.Cache;<span class="hljs-keyword">import</span> com.jfinal.plugin.redis.Redis;<span class="hljs-javadoc">/** * 自定义ResidSession解决集群会话共享 *<span class="hljs-javadoctag"> @author</span> alone */</span><span class="hljs-annotation">@SuppressWarnings</span>(<span class="hljs-string">"serial"</span>)<span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisSession</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> {</span>    <span class="hljs-keyword">private</span> String id;    <span class="hljs-keyword">private</span> SessionType type;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> createTime;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> destroyTime;    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; attrs;    <span class="hljs-javadoc">/**     * 会话类型，不同类型的会话其有效期不同     *<span class="hljs-javadoctag"> @author</span> alone     */</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> SessionType {        <span class="hljs-javadoc">/**         * 移动端，类型为1，会话有效期为一周         */</span>        MOBILE(<span class="hljs-number">1</span>, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>),        <span class="hljs-javadoc">/**         * 网页端，类型为2，会话有效期为半小时         */</span>        BROWSER(<span class="hljs-number">2</span>, <span class="hljs-number">1000</span> * <span class="hljs-number">60</span> * <span class="hljs-number">30</span>);        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> type;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;        <span class="hljs-keyword">private</span> <span class="hljs-title">SessionType</span>(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">int</span> value) {            <span class="hljs-keyword">this</span>.type = type;            <span class="hljs-keyword">this</span>.value = value;        }        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getType</span>() {            <span class="hljs-keyword">return</span> type;        }        <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span>() {            <span class="hljs-keyword">return</span> value;        }        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SessionType <span class="hljs-title">getSessionType</span>(<span class="hljs-keyword">int</span> type) {            <span class="hljs-keyword">for</span> (SessionType st : SessionType.values()) {                <span class="hljs-keyword">if</span> (st.type == type) {                    <span class="hljs-keyword">return</span> st;                }            }            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;        }    }    <span class="hljs-keyword">public</span> <span class="hljs-title">RedisSession</span>(<span class="hljs-keyword">int</span> sessionType) {        <span class="hljs-keyword">this</span>.id = RandomUtils.getUUID(<span class="hljs-keyword">true</span>);        <span class="hljs-keyword">this</span>.type = SessionType.getSessionType(sessionType);        <span class="hljs-keyword">this</span>.createTime = System.currentTimeMillis();        <span class="hljs-keyword">this</span>.destroyTime = <span class="hljs-keyword">this</span>.createTime + <span class="hljs-keyword">this</span>.type.value;        <span class="hljs-keyword">this</span>.attrs = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();    }    <span class="hljs-keyword">public</span> Object <span class="hljs-title">getAttribute</span>(String key) {        <span class="hljs-keyword">return</span> attrs.get(key);    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAttribute</span>(String key, Object value) {        attrs.put(key, value);        Cache cache = Redis.use();        cache.set(<span class="hljs-keyword">this</span>.getId(), <span class="hljs-keyword">this</span>);        cache.pexpire(<span class="hljs-keyword">this</span>.getId(), <span class="hljs-keyword">this</span>.getDestroyTime() - System.currentTimeMillis());<span class="hljs-comment">//set后会将生存时间清零，需要重新设置有效期</span>    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeAttribute</span>(String key) {        attrs.remove(key);        Cache cache = Redis.use();        cache.set(<span class="hljs-keyword">this</span>.getId(), <span class="hljs-keyword">this</span>);    }    <span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span>() {        <span class="hljs-keyword">return</span> id;    }    <span class="hljs-keyword">public</span> SessionType <span class="hljs-title">getType</span>() {        <span class="hljs-keyword">return</span> type;    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCreateTime</span>() {        <span class="hljs-keyword">return</span> createTime;    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDestroyTime</span>() {        <span class="hljs-keyword">return</span> destroyTime;    }    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDestroyTime</span>(<span class="hljs-keyword">long</span> destroyTime) {        <span class="hljs-keyword">this</span>.destroyTime = destroyTime;    }}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li><li style="color: rgb(153, 153, 153);">63</li><li style="color: rgb(153, 153, 153);">64</li><li style="color: rgb(153, 153, 153);">65</li><li style="color: rgb(153, 153, 153);">66</li><li style="color: rgb(153, 153, 153);">67</li><li style="color: rgb(153, 153, 153);">68</li><li style="color: rgb(153, 153, 153);">69</li><li style="color: rgb(153, 153, 153);">70</li><li style="color: rgb(153, 153, 153);">71</li><li style="color: rgb(153, 153, 153);">72</li><li style="color: rgb(153, 153, 153);">73</li><li style="color: rgb(153, 153, 153);">74</li><li style="color: rgb(153, 153, 153);">75</li><li style="color: rgb(153, 153, 153);">76</li><li style="color: rgb(153, 153, 153);">77</li><li style="color: rgb(153, 153, 153);">78</li><li style="color: rgb(153, 153, 153);">79</li><li style="color: rgb(153, 153, 153);">80</li><li style="color: rgb(153, 153, 153);">81</li><li style="color: rgb(153, 153, 153);">82</li><li style="color: rgb(153, 153, 153);">83</li><li style="color: rgb(153, 153, 153);">84</li><li style="color: rgb(153, 153, 153);">85</li><li style="color: rgb(153, 153, 153);">86</li><li style="color: rgb(153, 153, 153);">87</li><li style="color: rgb(153, 153, 153);">88</li><li style="color: rgb(153, 153, 153);">89</li><li style="color: rgb(153, 153, 153);">90</li><li style="color: rgb(153, 153, 153);">91</li><li style="color: rgb(153, 153, 153);">92</li><li style="color: rgb(153, 153, 153);">93</li><li style="color: rgb(153, 153, 153);">94</li><li style="color: rgb(153, 153, 153);">95</li><li style="color: rgb(153, 153, 153);">96</li><li style="color: rgb(153, 153, 153);">97</li><li style="color: rgb(153, 153, 153);">98</li><li style="color: rgb(153, 153, 153);">99</li><li style="color: rgb(153, 153, 153);">100</li><li style="color: rgb(153, 153, 153);">101</li><li style="color: rgb(153, 153, 153);">102</li><li style="color: rgb(153, 153, 153);">103</li><li style="color: rgb(153, 153, 153);">104</li><li style="color: rgb(153, 153, 153);">105</li><li style="color: rgb(153, 153, 153);">106</li><li style="color: rgb(153, 153, 153);">107</li><li style="color: rgb(153, 153, 153);">108</li><li style="color: rgb(153, 153, 153);">109</li><li style="color: rgb(153, 153, 153);">110</li></ul></pre><p>仿造getSession()实现逻辑在控制器基类BaseController中自定义getSession()方法，获取RedisSession：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs java has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Controller</span> {</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = Logger.getLogger(BaseController.class);    <span class="hljs-keyword">private</span> String sessionId;    <span class="hljs-javadoc">/**     * 获取RedisSession     *<span class="hljs-javadoctag"> @param</span> sessionType 会话类型     *<span class="hljs-javadoctag"> @return</span>     */</span>    <span class="hljs-annotation">@SuppressWarnings</span>(<span class="hljs-string">"null"</span>)    <span class="hljs-keyword">public</span> RedisSession <span class="hljs-title">getSession</span>(<span class="hljs-keyword">int</span> sessionType) {        <span class="hljs-keyword">boolean</span> isReload = <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">long</span> now = System.currentTimeMillis();        RedisSession session = <span class="hljs-keyword">null</span>;        Cache cache = Redis.use();        <span class="hljs-keyword">if</span> (sessionId == <span class="hljs-keyword">null</span>) {            Cookie[] cookies = getRequest().getCookies();            <span class="hljs-keyword">if</span> (cookies != <span class="hljs-keyword">null</span>) {                <span class="hljs-keyword">for</span> (Cookie cookie : cookies) {                    <span class="hljs-keyword">if</span> (cookie.getName().equals(<span class="hljs-string">"JSESSIONID"</span>)) {<span class="hljs-comment">//查看请求中是否有对应的Cookie记录</span>                        sessionId = cookie.getValue();<span class="hljs-comment">//本地记录此次请求的sessionId，防止在初次请求时后台多次获取session，获取的session均不同</span>                    }                }            }        }        <span class="hljs-keyword">if</span> (sessionId != <span class="hljs-keyword">null</span>) {            session = cache.get(sessionId);<span class="hljs-comment">//如果有，从redis中取出对应的Session</span>            <span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) {                <span class="hljs-keyword">if</span> (session.getType() == RedisSession.SessionType.BROWSER) {                    session.setDestroyTime(now + RedisSession.SessionType.BROWSER.getValue());<span class="hljs-comment">//若会话类型为浏览器则刷新其会话有效期</span>                    isReload = <span class="hljs-keyword">true</span>;                    logger.info(<span class="hljs-string">"刷新会话时间，JSESSIONID："</span> + session.getId() + <span class="hljs-string">"，延长："</span> + RedisSession.SessionType.BROWSER.getValue()/<span class="hljs-number">1000</span>/<span class="hljs-number">60</span>/<span class="hljs-number">60.0</span> + <span class="hljs-string">"小时"</span>);                }                <span class="hljs-keyword">if</span> (session.getDestroyTime() &lt; now) {<span class="hljs-comment">//若会话过期，从redis中删除</span>                    cache.del(session.getId());                    session = <span class="hljs-keyword">null</span>;                    logger.info(<span class="hljs-string">"删除过期会话，JSESSIONID："</span> + session.getId());                }            }        }        <span class="hljs-keyword">if</span> (session == <span class="hljs-keyword">null</span>) {            session = <span class="hljs-keyword">new</span> RedisSession(sessionType);<span class="hljs-comment">//若请求中没有对应Cookie记录，创建新的session</span>            sessionId = session.getId();<span class="hljs-comment">//本地记录此次请求的sessionId，防止在初次请求时后台多次获取session，获取的session均不同</span>            isReload = <span class="hljs-keyword">true</span>;            logger.info(<span class="hljs-string">"创建新会话，JSESSIONID："</span> + session.getId() + <span class="hljs-string">"，有效时间："</span> + (session.getDestroyTime() - now)/<span class="hljs-number">1000</span>/<span class="hljs-number">60</span>/<span class="hljs-number">60.0</span> + <span class="hljs-string">"小时"</span>);        }        <span class="hljs-keyword">if</span> (isReload) {<span class="hljs-comment">//session生命周期发生变化，需要重新redis中存储数据</span>            cache.set(session.getId(), session);<span class="hljs-comment">//将session存入redis中</span>            cache.pexpire(session.getId(), session.getDestroyTime() - now);<span class="hljs-comment">//设定redis数据储存有效期</span>        }        Cookie cookie = <span class="hljs-keyword">new</span> Cookie(<span class="hljs-string">"JSESSIONID"</span>, session.getId());        cookie.setPath(<span class="hljs-string">"/"</span>);        cookie.setHttpOnly(<span class="hljs-keyword">true</span>);        getResponse().addCookie(cookie);<span class="hljs-comment">//将cookie返回</span>        <span class="hljs-keyword">return</span> session;    }}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li><li style="color: rgb(153, 153, 153);">13</li><li style="color: rgb(153, 153, 153);">14</li><li style="color: rgb(153, 153, 153);">15</li><li style="color: rgb(153, 153, 153);">16</li><li style="color: rgb(153, 153, 153);">17</li><li style="color: rgb(153, 153, 153);">18</li><li style="color: rgb(153, 153, 153);">19</li><li style="color: rgb(153, 153, 153);">20</li><li style="color: rgb(153, 153, 153);">21</li><li style="color: rgb(153, 153, 153);">22</li><li style="color: rgb(153, 153, 153);">23</li><li style="color: rgb(153, 153, 153);">24</li><li style="color: rgb(153, 153, 153);">25</li><li style="color: rgb(153, 153, 153);">26</li><li style="color: rgb(153, 153, 153);">27</li><li style="color: rgb(153, 153, 153);">28</li><li style="color: rgb(153, 153, 153);">29</li><li style="color: rgb(153, 153, 153);">30</li><li style="color: rgb(153, 153, 153);">31</li><li style="color: rgb(153, 153, 153);">32</li><li style="color: rgb(153, 153, 153);">33</li><li style="color: rgb(153, 153, 153);">34</li><li style="color: rgb(153, 153, 153);">35</li><li style="color: rgb(153, 153, 153);">36</li><li style="color: rgb(153, 153, 153);">37</li><li style="color: rgb(153, 153, 153);">38</li><li style="color: rgb(153, 153, 153);">39</li><li style="color: rgb(153, 153, 153);">40</li><li style="color: rgb(153, 153, 153);">41</li><li style="color: rgb(153, 153, 153);">42</li><li style="color: rgb(153, 153, 153);">43</li><li style="color: rgb(153, 153, 153);">44</li><li style="color: rgb(153, 153, 153);">45</li><li style="color: rgb(153, 153, 153);">46</li><li style="color: rgb(153, 153, 153);">47</li><li style="color: rgb(153, 153, 153);">48</li><li style="color: rgb(153, 153, 153);">49</li><li style="color: rgb(153, 153, 153);">50</li><li style="color: rgb(153, 153, 153);">51</li><li style="color: rgb(153, 153, 153);">52</li><li style="color: rgb(153, 153, 153);">53</li><li style="color: rgb(153, 153, 153);">54</li><li style="color: rgb(153, 153, 153);">55</li><li style="color: rgb(153, 153, 153);">56</li><li style="color: rgb(153, 153, 153);">57</li><li style="color: rgb(153, 153, 153);">58</li><li style="color: rgb(153, 153, 153);">59</li><li style="color: rgb(153, 153, 153);">60</li><li style="color: rgb(153, 153, 153);">61</li><li style="color: rgb(153, 153, 153);">62</li></ul></pre><p>说明： <br><br>以上代码中，设想服务器给移动端和网页端同时提供服务，为了优化，但我希望移动端不需要频繁登录，就像微信一样，我将这个时间暂设一周；而网页端的话，session生存周期较短，只有半个小时，并且每次鉴权都刷新其可用时间，移动端只倒计时就可以了，一周登录一次就可以了。redis自带有过期策略，可以很好的实现这一点，同时为了保险起见，也手动验证了一下如过期，进行删除。为了避免初次请求时，多次调用getSession()生成多个session，故在创建session成功后记录其sessionId，再次调用getSession()时可对其进行验证。</p><h2 id="七结果测试"><a name="t6"></a>七、结果测试</h2><p>1.在Controller中编写两个接口，一为登录接口，登录成功，储存用户uid；二为验证登录接口，获取登录信息：</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs cs has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redisLogin</span>() {    RedisSession session = getSession(RedisSession.SessionType.BROWSER.getType());    session.setAttribute(<span class="hljs-string">"uid"</span>, <span class="hljs-number">1</span>);    renderText(<span class="hljs-string">"登录成功，sessionId："</span> + session.getId());}<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redisCheckLogin</span>() {    RedisSession session = getSession(RedisSession.SessionType.BROWSER.getType());    <span class="hljs-keyword">int</span> uid = (<span class="hljs-keyword">int</span>) session.getAttribute(<span class="hljs-string">"uid"</span>);    renderText(<span class="hljs-string">"sessionId："</span> + session.getId() + <span class="hljs-string">", uid: "</span> + uid);}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li><li style="color: rgb(153, 153, 153);">10</li><li style="color: rgb(153, 153, 153);">11</li><li style="color: rgb(153, 153, 153);">12</li></ul></pre><p>2.配置nginx分别跳转到不同tomcat下的不同接口</p><pre class="prettyprint" name="code" style="background-color: rgb(225, 230, 215);"><code class="hljs vala has-numbering" style="background-color: rgb(225, 230, 215);"><span class="hljs-preprocessor">#测试登录接口跳到8080</span>location = /tomcat1 {    proxy_pass http:<span class="hljs-comment">//localhost:8080/mate/test/redisLogin;</span>}<span class="hljs-preprocessor">#校验登录接口跳到8081</span>location = /tomcat2 {    proxy_pass http:<span class="hljs-comment">//localhost:8081/mate/test/redisCheckLogin;</span>}</code><ul class="pre-numbering" style=""><li style="color: rgb(153, 153, 153);">1</li><li style="color: rgb(153, 153, 153);">2</li><li style="color: rgb(153, 153, 153);">3</li><li style="color: rgb(153, 153, 153);">4</li><li style="color: rgb(153, 153, 153);">5</li><li style="color: rgb(153, 153, 153);">6</li><li style="color: rgb(153, 153, 153);">7</li><li style="color: rgb(153, 153, 153);">8</li><li style="color: rgb(153, 153, 153);">9</li></ul></pre><p>3.开启redis，nginx，两个tomcat下运行同样的项目，在浏览器中调用接口进行测试。</p><p>调用tomcat1的登录接口 <br><br><img src="https://img-blog.csdn.net/20170824170605654?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br><br>日志： <br><br><img src="https://img-blog.csdn.net/20170824170908868?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><p>调用tomcat2的登录接口 <br><br><img src="https://img-blog.csdn.net/20170824171238001?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""> <br><br>日志： <br><br><img src="https://img-blog.csdn.net/20170824171332397?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcWlubWVuZ2RlQ2x1bnRhbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述" title=""></p><p>可以看到，两个tomcat中的信息完全一样，很好的达到了我们预计的效果。</p><p></p><p>到这里，本篇的内容也已经到了尾声，写的有点啰嗦，不过总算交代了来龙去脉，虽然有点累，但好歹写完了。未来还有很多工作要做，路漫漫其修远兮，吾将上下而求索。&lt;/ p&gt; &lt;/ div&gt; <link rel="“stylesheet”href" =“="" https:="" csdnimg.cn="" release="" phoenix="" template="" css="" markdown_views-ea0013b516.css="" ”=""> &lt;/ div&gt;</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;p&gt;&lt;div id=&quot;article_content&quot; class=&quot;article_content csdn-tracking-statistics&quot; data-pid=&quot;bl
      
    
    </summary>
    
      <category term="Java" scheme="http://wjlfun.info/categories/Java/"/>
    
    
      <category term="Session" scheme="http://wjlfun.info/tags/Session/"/>
    
  </entry>
  
  <entry>
    <title>Struts2</title>
    <link href="http://wjlfun.info/2015/12/17/struts2/"/>
    <id>http://wjlfun.info/2015/12/17/struts2/</id>
    <published>2015-12-16T16:00:00.000Z</published>
    <updated>2018-02-02T00:15:16.279Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Struts2"><a href="#Struts2" class="headerlink" title="Struts2"></a>Struts2</h1><h2 id="一、框架概述"><a href="#一、框架概述" class="headerlink" title="一、框架概述"></a>一、框架概述</h2><p>什么是框架，为什么使用框架，框架优点<br>框架（framework）是一个基本概念上的结构，用于去解决或者处理复杂的问题<br>框架，即framework。其实就是某种应用的半成品，就是一组组件，供你选用完成你自己的系统。简单说就是使用别人搭好的舞台，你来做表演。<br>框架是在特定的领域内解决问题。<br>优点<br>重用代码大大增加，软件生产效率和质量也得到了提高<br>使用框架开发，它提供统一的标准，大大降低了我们的后期维护。<br>学习框架重点:了解框架做了什么，我们要在这个基础上在做什么事情。</p><h2 id="二、java开发中常用框架"><a href="#二、java开发中常用框架" class="headerlink" title="二、java开发中常用框架"></a>二、java开发中常用框架</h2><p>SSH   (SSM  SSI)<br>SSH  struts2  spring  hibernate<br>SSM(SSI) springmvc spring mybatis(ibatis)</p><p>SSH 它是企业开发中比较主流的一套架构。<br>SSH框架在开发中所处的位置:</p><h2 id="三、Struts2框架介绍"><a href="#三、Struts2框架介绍" class="headerlink" title="三、Struts2框架介绍"></a>三、Struts2框架介绍</h2><p>什么是struts2框架，学习struts2框架的核心。<br>Struts2是一个基于MVC设计模式的Web应用框架，它本质上相当于一个servlet，在MVC设计模式中，Struts2作为控制器(Controller)来建立模型与视图的数据交互<br>Struts2=struts1+webwork</p><p>问题:struts2是一个mvc框架，它的mvc是什么?</p><p>javaweb开发中的mvc,是在jsp的model2模式中提过<br>Model——javabean<br>View——–jsp<br>Controller—-servlet</p><p>核心点:<br>1.拦截器 interceptor<br>2.Action<br>3.ognl与valueStack</p><p>在现在开发中与struts2比较类似的框架有哪些?<br>Struts1  webwork  springmvc  jsf</p><p>Struts2框架流程</p><h2 id="四、Struts2框架执行流程"><a href="#四、Struts2框架执行流程" class="headerlink" title="四、Struts2框架执行流程"></a>四、Struts2框架执行流程</h2><p>1．Struts2源码导入</p><p>对于struts2框架它的源代码我们主要使用三部分<br>1.struts2核心部分源代码  org.apache.struts2xx<br>src\core\src\main\java<br>2.struts2的xwork核心部分源代码<br>src\xwork-core\src\main\java\com\opensymphony\xwork2<br>3.struts2的插件的源代码<br>src\plugins<br>2．关于struts.xml配置文件中提示问题<br>第一步<br>在eclipse的window下首选面中查找xml catalog<br>第二步<br>Location:配置本地的dtd文件路径<br>key type:选择URI<br>Key: <a href="http://struts.apache.org/dtds/struts-2.3.dtd" target="_blank" rel="noopener">http://struts.apache.org/dtds/struts-2.3.dtd</a><br>注意版本要对应，如果你可以上网，那么会自动缓存dtd,具有提示功能。</p><p>3．执行流程介绍<br>1.当通过浏览器发送一个请求<br>2.会被StrutsPrepareAndExecuteFilter拦截<br>3.会调用strtus2框架默认的拦截器(interceptor)完成部分功能<br>4.在执行Action中操作<br>5.根据Action中方法的执行结果来选择来跳转页面Resutl视图</p><p>一般管StrutsPrepareAndExecuteFilter 叫做前端控制器(核心控制器)，只有配置了这个filter我们的strtus2框架才能使用。<br>Strtus2的默认拦截器(interceptor)它们是在struts-default.xml文件中配置<br>注意:这上xml文件是在strtus-core.jar包中。<br>默认的拦截器是在defaultStack中定义的。</p><h2 id="五、Struts2配置详解"><a href="#五、Struts2配置详解" class="headerlink" title="五、Struts2配置详解"></a>五、Struts2配置详解</h2><p>1．Struts2配置文件加载顺序</p><p>第一个加载的是default.properties文件<br>位置:strtus2-core.jar包   org.apache.struts2包下<br>作用:主要是声明了struts2框架的常量<br>第二个加载的是一批配置文件<br>Strtus-default.xml<br>位置:struts2-corl.jar<br>作用:声明了interceptor  result  bean<br>Strtus-plugin.xml<br>位置:在strtus2的插件包中<br>作用:主要用于插件的配置声明<br>Strtus.xml<br>位置:在我们自己的工程中<br>作用:用于我们自己工程使用strtus2框架的配置<br>第三个加载的是自定义的strtus.properties<br>位置:都是在自己工程的src下<br>作用:定制常量<br>第四自定义配置提供<br>第五加载的是web.xml配置文件<br>主要是加载strtus2框架在web.xml文件中的相关配置.<br>第六 bean相关配置</p><p>重点掌握:<br>1.Default.properties<br>2.Struts-default.xml<br>3.Struts-plugin.xml<br>4.Strtus.xml<br>5.web.xml</p><p>2．struts.xml文件配置介绍<br>2.1．package配置<br>1.name属性  作用:定义一个包的名称，它必须唯一。<br>2.namespace属性 作用:主要是与action标签的name属性联合使用来确定一个action    的访问路径<br>3.extends属性 作用:指定继承自哪个包。一般值是strtus-default<br>        strtus-default包是在strtus-default.xml文件中声明的。<br>4.abstruct属性 它代表当前包是一个抽象的，主要是用于被继承<br>2.2．action配置<br>1.name属性 作用:主要是与package的namespace联合使用来确定一个action的访问路    径<br>2.class属性  作用:用于指示当前的action类<br>3.method属性  作用:用于指示当前的action类中的哪个方法执行<br>2.3．result配置<br>它主要是用于指示结果视图<br>1.name属性 作用是与action类的method方法的返回值进行匹配，来确定跳转路径<br>2.type属性 作用是用于指定跳转方式<br>2.4．扩展<br>关于action配置中的class与method的默认值以及result中的name与type 默认值问题</p><p>原因:strtus-default.xml文件中配置</p><p>它的作用就是当一个请求来时，如果查找不到指定的class及对应的method就会执行<br>ActionSupport类中的execute方法。<br>在这个类的execute方法中默认返回的是”success”<br>也就是说，result的name属性默认值是success,默认的跳转方式是请求转发 dispatcher</p><p>3．常量配置<br>default.properties文件中定义了struts2框架常用常量 .<br>问题:我们怎样可以定义常量<br>1.可以在src下创建一个strtus.properties配置文件<br>2.可以在web.xml文件中配置<br>3.可以直接在strtus.xml文件中定义常量 (推荐)</p><p>注意:后加载的配置文件中的常量会将先加载的常量覆盖</p><h2 id="六、Struts2的Action详解"><a href="#六、Struts2的Action详解" class="headerlink" title="六、Struts2的Action详解"></a>六、Struts2的Action详解</h2><p>Struts2中的action，主要是完成业务逻辑操作。Action替代在servlet中完成的作用。<br>Action的学习主要有两点<br>1.如何创建一个struts2的action<br>2.如果访问一个struts2的action</p><p>1．Action类创建方式(三种)<br>1.创建一个pojo类<br>Pojo(plani Ordinary java object)简单的java对象<br>Pojo类就是没有实现任何接口没有继承任何类<br>优点:无耦合<br>缺点:所有的功能都要自己完成</p><p>2.创建一个类实现一个Action接口<br>com.opensymphony.xwork2.Action</p><p>在Action接口中定义了五个常量，一个execute方法<br>五个常量:它们是默认的五个结果视图<result name="””">:<br>ERROR : 错误视图<br>INPUT: 它是struts2框架中interceptor中发现问题后会访问的一个视图<br>LOGIN:它是一个登录视图，可以在权限操作中使用<br>NONE:它代表的是null,什么都不做（也不会做跳转操作）<br>SUCCESS:这是一个成功视图<br>优点：耦合度低<br>缺点:还是需要自己来完成功能</result></p><p>3.创建一个类继承ActionSupport类<br>com.opensymphony.xwork2.ActionSupport<br>ActionSupport类也实现了Action接口。<br>我们在开发中一般会使用这种方案:<br>优点:具有丰富的功能，例如  表单校验 错误信息设置  国际化<br>缺点:耦合度高<br>2．action的访问方式<br>1.直接通过<action>标签来配置，通过method来指定访问的方法，如果method没有，默认访问的是execute方法。<br>2.简化的action访问方式，可以使用<em>通配符来访问。<br>这种方式的缺点:不建议使用过多的</em>号，它带来程序阅读障碍，不便于理解<br>使用*来简化操作方案，它对名称规范必须进行一个统一。</action></p><p>3．扩展–动态方法调用</p><p>这是strtus2提供的动态方法调用。</p><p>注意:对于strtus2的动态方法调用，要想使用我们必须配置一个常量来开启动态方法调用</p><p>这代表动态方法调用没有开启</p><p>个人不建议使用动态方法调用</p><h2 id="七、Struts2框架封装数据"><a href="#七、Struts2框架封装数据" class="headerlink" title="七、Struts2框架封装数据"></a>七、Struts2框架封装数据</h2><p>主要解决的问题:是在action中如果获取请求参数</p><p>主要有两种方式:<br>1.属性驱动<br>a.直接在action类中提供与请求参数匹配属性，提供get/set方法<br>b.在action类中创始一个javaBean,对其提供get/set ，在请求时页面上要进行修改，      例如 user.username  user.password ,要使用ognl表达式<br>以上两种方式的优缺点:<br>第一种比较简单，在实际操作我们需要将action的属性在赋值给模型(javaBean)    去操作<br>    第二种:不需要在直接将值给javaBean过程，因为直接将数据封装到了javaBean    中。它要求在页面上必须使用ognl表达式，就存在页面不通用问题。</p><p>2.模型驱动<br>步骤:<br>1.让Action类要实现一个指定接口ModelDriven<br>2.实例化模型对象(就是要new出来javaBean)<br>3.重写getModel方法将实例化的模型返回。</p><p>对于模型驱动它与属性驱动对比，在实际开发中使用比较多，模型驱动缺点，它只能对    一个模型数据进行封装。</p><h2 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h2><p>1.关于strtus2框架的环境搭建<br>2.关于strtus2框架配置<br>3.关于strtus2框架请求参数封装<br>4.关于strtus2框架的路径跳转</p><p>关于action访问的配置</p><package name="””" namespace="””" extends="””"><br><action name="””" class="””" method="””"><br><result name="””" type="””">路径</result><br></action><br></package><p>关于路径跳转问题:<br>是通过<result>来配置跳转的路径.<br>它的name属性是与action中的方法的返回值进行对比的。<br>它的type属性可以取哪些值?</result></p><p>默认值是dispatcher 它代表的是请求转发。针对于jsp页面<br>redirect  它代表的是重定向   针对于jsp页面<br>chain  它类似于请示转发，只不过它是针对于action跳转.<br>redirectAction 它类似于重定向  针对于action<br>关于路径跳转的配置<br>可以直接在<package>下创建全局的result</package></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Struts2&quot;&gt;&lt;a href=&quot;#Struts2&quot; class=&quot;headerlink&quot; title=&quot;Struts2&quot;&gt;&lt;/a&gt;Struts2&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="Java" scheme="http://wjlfun.info/categories/Java/"/>
    
    
      <category term="Struts2" scheme="http://wjlfun.info/tags/Struts2/"/>
    
  </entry>
  
  <entry>
    <title>浏览器插件的使用教程</title>
    <link href="http://wjlfun.info/2015/09/23/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <id>http://wjlfun.info/2015/09/23/浏览器插件的使用教程/</id>
    <published>2015-09-22T16:00:00.000Z</published>
    <updated>2018-01-28T13:28:26.012Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="浏览器插件的使用教程"><a href="#浏览器插件的使用教程" class="headerlink" title="浏览器插件的使用教程"></a>浏览器插件的使用教程</h1><h2 id="安装油猴插架"><a href="#安装油猴插架" class="headerlink" title="安装油猴插架"></a>安装油猴插架</h2><ul><li>[下载安装][<a href="http://www.tampermonkey.net" target="_blank" rel="noopener">http://www.tampermonkey.net</a>]</li><li>选择和你浏览器对应的插架，如下图<br>  <img src="http://os4z8t7lb.bkt.clouddn.com/201709031141_995.png" alt=""></li><li>安装成功后可以在浏览器插件（扩展）中看到油猴，如下图<br>  <img src="http://os4z8t7lb.bkt.clouddn.com/201709031143_316.png" alt=""></li></ul><h2 id="使用油猴安装插件"><a href="#使用油猴安装插件" class="headerlink" title="使用油猴安装插件"></a>使用油猴安装插件</h2><ul><li>点击油猴图标可以打开油猴的控制面板，如下图<br>   <img src="http://os4z8t7lb.bkt.clouddn.com/201709031145_947.png" alt=""></li><li>点击[获取新脚本][<a href="http://tampermonkey.net/scripts.php" target="_blank" rel="noopener">http://tampermonkey.net/scripts.php</a>]</li><li>选择脚本网站，推荐使用<a href="https://greasyfork.org/zh-CN" target="_blank" rel="noopener">GreasyFork</a><br>  <img src="http://os4z8t7lb.bkt.clouddn.com/201709031147_863.png" alt=""></li></ul><h2 id="选择要安装的脚本"><a href="#选择要安装的脚本" class="headerlink" title="选择要安装的脚本"></a>选择要安装的脚本</h2><ul><li>在首页点击脚本列表<br>   <img src="http://os4z8t7lb.bkt.clouddn.com/201709031149_210.png" alt=""></li><li>选择你需要的脚本点击安装<br>  <img src="http://os4z8t7lb.bkt.clouddn.com/201709031150_460.png" alt=""></li><li>点击进行安装，如下图<br>  <img src="http://os4z8t7lb.bkt.clouddn.com/201709031152_320.png" alt=""><br>  <img src="http://os4z8t7lb.bkt.clouddn.com/201709031938_626.png" alt=""></li><li>安装成功后可以在油猴面板查看<br>  <img src="http://os4z8t7lb.bkt.clouddn.com/201709031527_545.png" alt=""><br>  <img src="http://os4z8t7lb.bkt.clouddn.com/201709031529_999.png" alt=""><blockquote><p>插件可根据自己的需求安装，在脚本列表中可以看到很多有意思的插件</p></blockquote></li></ul><h2 id="举例：查看VIP视频"><a href="#举例：查看VIP视频" class="headerlink" title="举例：查看VIP视频"></a>举例：查看VIP视频</h2><ol><li>安装<code>VIP视频在线解析</code>插件</li><li>打开视频网站，播放视频，可看到插件，如下图<br> <img src="http://os4z8t7lb.bkt.clouddn.com/201709032010_638.png" alt="优酷网站"><br> <img src="http://os4z8t7lb.bkt.clouddn.com/201709032016_912.png" alt="爱奇艺"><br> <img src="http://os4z8t7lb.bkt.clouddn.com/201709032020_721.png" alt="腾讯视频"><blockquote><p>解析VIP 视频的插件很多，选一个可以用的即可，也可以安装多个<br>插件的作用只是</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;浏览器插件的使用教程&quot;&gt;&lt;a href=&quot;#浏览器插件的使用教程&quot; class=&quot;headerlink&quot; title=&quot;浏览器插件的使用教程&quot;&gt;&lt;/a&gt;浏览器插件的
      
    
    </summary>
    
      <category term="Life" scheme="http://wjlfun.info/categories/Life/"/>
    
    
      <category term="浏览器插件" scheme="http://wjlfun.info/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>Linux</title>
    <link href="http://wjlfun.info/2015/09/21/Linux/"/>
    <id>http://wjlfun.info/2015/09/21/Linux/</id>
    <published>2015-09-20T16:00:00.000Z</published>
    <updated>2018-01-30T05:57:23.092Z</updated>
    
    <content type="html"><![CDATA[<script src="\assets\js\APlayer.min.js"> </script><h1 id="Linux学习"><a href="#Linux学习" class="headerlink" title="Linux学习"></a>Linux学习</h1><h2 id="初学者必备"><a href="#初学者必备" class="headerlink" title="初学者必备"></a>初学者必备</h2><ol><li>Linux常用命令</li></ol><h3 id="01-Linux的简介-avi"><a href="#01-Linux的简介-avi" class="headerlink" title="01-Linux的简介.avi"></a>01-Linux的简介.avi</h3><p>什么是Linux<br>Linux是基于Unix的,是一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。<br>Linux的应用<br>服务器系统: Web应用服务器、数据库服务器、接口服务器、DNS、FTP等等<br>嵌入式系统: 路由器、防火墙、手机、PDA、IP 分享器、交换器、家电用品的微电脑控制器等等<br>高性能运算、计算密集型应用 Linux有强大的运算能力<br>桌面应用系统<br>移动手持系统<br>Linux的主流版本<br>Ubuntu, Centos, redhat, fedora, freebsd…</p><h3 id="02-虚拟软件的安装-avi"><a href="#02-虚拟软件的安装-avi" class="headerlink" title="02-虚拟软件的安装.avi"></a>02-虚拟软件的安装.avi</h3><p>安装参考《虚拟软件vmware安装.doc》</p><h3 id="03-CentOS的安装-avi"><a href="#03-CentOS的安装-avi" class="headerlink" title="03-CentOS的安装.avi"></a>03-CentOS的安装.avi</h3><p>参考《CentOS6详细安装文档.doc》</p><h3 id="04-Linux的目录结构-avi"><a href="#04-Linux的目录结构-avi" class="headerlink" title="04-Linux的目录结构.avi"></a>04-Linux的目录结构.avi</h3><p><img src="http://os4z8t7lb.bkt.clouddn.com/201801222253_456.png" alt=""></p><h3 id="05-Linux的常用命令：cd命令-avi"><a href="#05-Linux的常用命令：cd命令-avi" class="headerlink" title="05-Linux的常用命令：cd命令.avi"></a>05-Linux的常用命令：cd命令.avi</h3><p>==切换目录==<br><code>cd app</code> 切换到app目录<br><code>cd ..</code> 切换到上一层目录<br><code>cd /</code> 切换到系统根目录<br><code>cd ~</code> 切换到用户主目录<br><code>cd -</code> 切换到上一个所在目录</p><h3 id="06-Linux的常用命令：ls、ll、dir命令-avi"><a href="#06-Linux的常用命令：ls、ll、dir命令-avi" class="headerlink" title="06-Linux的常用命令：ls、ll、dir命令.avi"></a>06-Linux的常用命令：ls、ll、dir命令.avi</h3><p>==列出文件列表==<br>ls(list)是一个非常有用的命令，用来显示当前目录下的内容。配合参数的使用，能以不同的方式显示目录内容<br>格式：ls[参数] [路径或文件名]</p><p>在linux中以 <code>.</code> 开头的文件都是隐藏的文件<br><code>ls</code><br><code>ls -a</code>  显示所有文件或目录（包含隐藏的文件）<br><code>ls -l</code>  缩写成ll</p><h3 id="07-Linux的常用命令：mkdir、rmdir命令-avi"><a href="#07-Linux的常用命令：mkdir、rmdir命令-avi" class="headerlink" title="07-Linux的常用命令：mkdir、rmdir命令.avi"></a>07-Linux的常用命令：mkdir、rmdir命令.avi</h3><p>==创建目录==<br><code>mkdir app</code> 在当前目录下创建app目录<br><code>mkdir –p app2/test</code> 级联创建aap2以及test目<br>==移除目录==<br><code>rmdir(remove directory)</code>命令可用来删除“空”的子目录<br><code>rmdir app</code>  删除app目录</p><h3 id="08-Linux的常用命令：cat、more、less、tail命令-avi"><a href="#08-Linux的常用命令：cat、more、less、tail命令-avi" class="headerlink" title="08-Linux的常用命令：cat、more、less、tail命令.avi"></a>08-Linux的常用命令：cat、more、less、tail命令.avi</h3><p>浏览文件</p><p><code>cat</code> 用于显示文件的内容<br>格式：cat[参数]&lt;文件名&gt;<br><code>cat yum.conf</code></p><p><code>more</code> 一般用于要显示的内容会超过一个画面长度的情况。按空格键显示下一个画面。回车显示下一行内容。按 q 键退出查看。<br><code>more yum.conf</code> 空格显示下一页数据  回车显示下一行的数据</p><p><code>less</code> 用法和<code>more</code>类似，不同的是less可以通过PgUp、PgDn键来控制<br><code>less yum.conf</code>  PgUp 和 PgDn 进行上下翻页.</p><p><code>tail</code>命令是在实际使用过程中使用非常多的一个命令，它的功能是：用于显示文件后几行的内容。<br>==<code>tail -10 /etc/passwd</code>  查看后10行数据==<br><code>tail -f catalina.log</code>  ==动态查看日志==<br><code>ctrl+c</code> 结束查看</p><h3 id="09-Linux的常用命令：rm命令-avi"><a href="#09-Linux的常用命令：rm命令-avi" class="headerlink" title="09-Linux的常用命令：rm命令.avi"></a>09-Linux的常用命令：rm命令.avi</h3><p>==文件删除操作==<br><code>rm</code>  删除文件<br><code>rm a.txt</code>  删除a.txt文件<br>删除需要用户确认，y/n rm 删除不询问<br><code>rm -f a.txt</code>  不询问，直接删除 rm 删除目录<br><code>rm -r a</code>  递归删除<br>不询问递归删除（慎用）<br><code>rm -rf  a</code>  不询问递归删除<br><code>rm -rf *</code>    删除所有文件<br><code>rm -rf /*</code>   自杀</p><h3 id="10-Linux的远程连接：CRT的软件的安装和使用-avi"><a href="#10-Linux的远程连接：CRT的软件的安装和使用-avi" class="headerlink" title="10-Linux的远程连接：CRT的软件的安装和使用.avi"></a>10-Linux的远程连接：CRT的软件的安装和使用.avi</h3><h3 id="11-Linux的常用命令：cp、mv命令-avi"><a href="#11-Linux的常用命令：cp、mv命令-avi" class="headerlink" title="11-Linux的常用命令：cp、mv命令.avi"></a>11-Linux的常用命令：cp、mv命令.avi</h3><p>文件的拷贝和剪切<br>cp(copy)命令可以将文件从一处复制到另一处。一般在使用cp命令时将一个文件复制成另一个文件或复制到某目录时，需要指定源文件名与目标文件名或目录。<br><code>cp a.txt b.txt</code>   将a.txt复制为b.txt文件<br><code>cp a.txt ../</code>     将a.txt文件复制到上一层目录中 </p><p>mv 移动或者重命名<br><code>mv a.txt ../</code>   将a.txt文件移动到上一层目录中<br><code>mv a.txt b.txt</code> 将a.txt文件重命名为b.txt</p><h3 id="12-Linux的常用命令：tar命令-avi"><a href="#12-Linux的常用命令：tar命令-avi" class="headerlink" title="12-Linux的常用命令：tar命令.avi"></a>12-Linux的常用命令：tar命令.avi</h3><p>==打包或者解压==<br>tar命令位于/bin目录下，它能够将用户所指定的文件或目录打包成一个文件，但不做压缩。<br>一般Linux上常用的压缩方式是选用tar将许多文件打包成一个文件，再以gzip压缩命令压缩成xxx.tar.gz(或称为xxx.tgz)的文件。<br>常用参数：<br><code>-c:</code>创建一个新tar文件<br><code>-v:</code>显示运行过程的信息<br><code>-f:</code>指定文件名<br><code>-z:</code>调用gzip压缩命令进行压缩<br><code>-t:</code>查看压缩文件的内容<br><code>-x:</code>解开tar文件</p><p>==打包==<br><code>tar –cvf xxx.tar ./*</code><br>打包并且压缩：<br><code>tar –zcvf xxx.tar.gz ./*</code></p><p>==解压==<br><code>tar –xvf xxx.tar</code><br><code>tar -xvf xxx.tar.gz -C /usr/aaa</code></p><h3 id="13-Linux的常用命令：grep命令-avi"><a href="#13-Linux的常用命令：grep命令-avi" class="headerlink" title="13-Linux的常用命令：grep命令.avi"></a>13-Linux的常用命令：grep命令.avi</h3><p>grep命令<br>查找符合条件的字符串<br>用法: grep [选项]… PATTERN [FILE]…<br>示例：<br><code>grep lang anaconda-ks.cfg</code>  在文件中查找lang<br><code>grep lang anaconda-ks.cfg –color</code> 高亮显示</p><h3 id="14-Linux的常用命令：其他常用命令-avi"><a href="#14-Linux的常用命令：其他常用命令-avi" class="headerlink" title="14-Linux的常用命令：其他常用命令.avi"></a>14-Linux的常用命令：其他常用命令.avi</h3><p>其他常用命令<br><code>pwd</code> 显示当前所在目录<br><code>touch</code> 创建一个空文件<br><code>touch a.txt</code><br><code>ll -h</code> 友好显示文件大小<br><code>wget</code> 下载资料 <code>wget http://nginx.org/download/nginx-1.9.12.tar.gz</code></p><h3 id="15-Linux的常用命令：VI和VIM编辑器-avi"><a href="#15-Linux的常用命令：VI和VIM编辑器-avi" class="headerlink" title="15-Linux的常用命令：VI和VIM编辑器.avi"></a>15-Linux的常用命令：VI和VIM编辑器.avi</h3><p>==Vi和Vim编辑器==<br>在Linux下一般使用vi编辑器来编辑文件<br>vi既可以查看文件也可以编辑文件<br>三种模式：命令行、插入、底行模式<br>切换到命令行模式：按Esc键<br>切换到插入模式：按 i 、o、a键<br><code>i</code> 在当前位置生前插入<br><code>I</code> 在当前行首插入<br><code>a</code> 在当前位置后插入<br><code>A</code> 在当前行尾插入<br><code>o</code> 在当前行之后插入一行<br><code>O</code> 在当前行之前插入一行</p><p>切换到底行模式：按 <code>:</code>（冒号）</p><p>打开文件：<code>vim file</code><br>退出：<code>esc :q</code><br>修改文件：输入<code>i</code>进入插入模式<br>保存并退出：<code>esc :wq</code><br>不保存退出：<code>esc :q!</code></p><h3 id="16-Linux的常用命令：重定向输出-avi"><a href="#16-Linux的常用命令：重定向输出-avi" class="headerlink" title="16-Linux的常用命令：重定向输出.avi"></a>16-Linux的常用命令：重定向输出.avi</h3><p><code>&gt;</code>  重定向输出，覆盖原有内容<br><code>&gt;&gt;</code> 重定向输出，又追加功能</p><p><code>cat /etc/passwd &gt; a.txt</code>  将输出定向到a.txt中<br><code>cat /etc/passwd &gt;&gt; a.txt</code>  输出并且追加</p><p><code>ifconfig &gt; ifconfig.txt</code></p><h3 id="17-Linux的常用命令：管道和命令执行控制-avi"><a href="#17-Linux的常用命令：管道和命令执行控制-avi" class="headerlink" title="17-Linux的常用命令：管道和命令执行控制.avi"></a>17-Linux的常用命令：管道和命令执行控制.avi</h3><p>管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入</p><p><code>ls --help | more</code>  分页查询帮助信息<br><code>ps –ef | grep java</code>  查询名称中包含java的进程<br><code>ifconfig | more</code><br><code>cat index.html | more</code><br><code>ps –ef | grep aio</code></p><p>命令控制<br>命令之间使用 <code>&amp;&amp;</code> 连接，实现逻辑与的功能<br>只有在 <code>&amp;&amp;</code> 左边的命令返回真,<code>&amp;&amp;</code> 右边的命令才会被执行<br>只要有一个命令返回假,后面的命令就不会被执行。<br><code>mkdir test &amp;&amp; cd test</code></p><h3 id="18-Linux的常用命令：网络通讯的命令-avi"><a href="#18-Linux的常用命令：网络通讯的命令-avi" class="headerlink" title="18-Linux的常用命令：网络通讯的命令.avi"></a>18-Linux的常用命令：网络通讯的命令.avi</h3><p>网络通讯命令<br><code>ifconfig</code>  显示或设置网络设备<br><code>ifconfig eth0 up</code> 启用eth0网卡<br><code>ifconfig eth0 down</code>  停用eth0网卡 ping   探测网络是否通畅。<br><code>ping 192.168.0.1 netstat</code> 查看网络端口。<br><code>netstat -an | grep 3306</code> 查询3306端口占用情况</p><h3 id="19-Linux的常用命令：系统管理的命令-avi"><a href="#19-Linux的常用命令：系统管理的命令-avi" class="headerlink" title="19-Linux的常用命令：系统管理的命令.avi"></a>19-Linux的常用命令：系统管理的命令.avi</h3><p>系统管理命令<br><code>date</code> 显示或设置系统时间<br><code>date</code>  显示当前系统时间<br><code>date -s “2014-01-01 10:10:10“</code>  设置系统时间 df 显示磁盘信息<br><code>df –h</code>  友好显示大小 free 显示内存状态<br><code>free –m</code> 以mb单位显示内存组昂头 top 显示，管理执行中的程序</p><p><code>clear</code> 清屏幕<br><code>ps</code> 正在运行的某个进程的状态<br><code>ps –ef</code>  查看所有进程<br><code>ps –ef | grep ssh</code> 查找某一进程 kill 杀掉某一进程<br><code>kill 2868</code>  杀掉2868编号的进程<br><code>kill -9 2868</code>  强制杀死进程</p><p><code>du</code> 显示目录或文件的大小<br><code>du –h</code> 显示当前目录的大小<br><code>who</code> 显示目前登入系统的用户信息<br><code>hostname</code> 查看当前主机名<br>修改：<code>vi /etc/sysconfig/network</code><br><code>uname</code> 显示系统信息。<br><code>uname -a</code> 显示本机详细信息<br>依次为：内核名称(类别)，主机名，内核版本号，内核版本，内核编译日期，硬件名，处理器类型，硬件平台类型，操作系统名称</p><h3 id="20-Linux的常用命令：用户管理的命令-avi"><a href="#20-Linux的常用命令：用户管理的命令-avi" class="headerlink" title="20-Linux的常用命令：用户管理的命令.avi"></a>20-Linux的常用命令：用户管理的命令.avi</h3><p>用户管理命令<br><code>useradd</code> 添加一个用户<br><code>useradd test</code> 添加test用户<br><code>useradd test -d /home/t1</code>  指定用户home目录<br><code>passwd</code>  设置、修改密码<br><code>passwd test</code>  为test用户设置密码</p><p>切换登录：<br><code>ssh -l test -p 22 192.168.19.128</code><br><code>su – 用户名</code><br><code>userdel</code> 删除一个用户<br><code>userdel test</code> 删除test用户(不会删除home目录)<br><code>userdel –r test</code>  删除用户以及home目录</p><h3 id="21-Linux的常用命令：组管理的命令-avi"><a href="#21-Linux的常用命令：组管理的命令-avi" class="headerlink" title="21-Linux的常用命令：组管理的命令.avi"></a>21-Linux的常用命令：组管理的命令.avi</h3><p>组管理命令<br>当在创建一个新用户user时，若没有指定他所属于的组，就建立一个和该用户同名的私有组<br>创建用户时也可以指定所在组<br><code>groupadd</code>  创建组<br><code>groupadd public</code>  创建一个名为public的组<br><code>useradd u1 –g public</code>  创建用户指定组 groupdel 删除组，如果该组有用户成员，必须先删除用户才能删除组。<br><code>groupdel public</code></p><h3 id="22-Linux的常用命令：权限管理-avi"><a href="#22-Linux的常用命令：权限管理-avi" class="headerlink" title="22-Linux的常用命令：权限管理.avi"></a>22-Linux的常用命令：权限管理.avi</h3><p>文件权限<br><img src="http://os4z8t7lb.bkt.clouddn.com/201801231353_92.png" alt=""><br>变更文件权限<br><code>chmod</code> 变更文件或目录的权限。<br><code>chmod 755 a.txt</code><br><code>chmod u=rwx,g=rx,o=rx a.txt</code><br><code>chmod 000 a.txt  / chmod 777 a.txt chown</code> ==变更文件或目录改文件所属用户和组==<br><code>chown u1:public a.txt</code> ：变更当前的目录或文件的所属用户和组<br><code>chown -R u1:public dir</code> ：变更目录中的所有的子目录及文件的所属用户和组</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;script src=&quot;\assets\js\APlayer.min.js&quot;&gt; &lt;/script&gt;&lt;h1 id=&quot;Linux学习&quot;&gt;&lt;a href=&quot;#Linux学习&quot; class=&quot;headerlink&quot; title=&quot;Linux学习&quot;&gt;&lt;/a&gt;Linux学习&lt;/h1&gt;&lt;h2
      
    
    </summary>
    
      <category term="Java" scheme="http://wjlfun.info/categories/Java/"/>
    
    
      <category term="Linux" scheme="http://wjlfun.info/tags/Linux/"/>
    
  </entry>
  
</feed>
